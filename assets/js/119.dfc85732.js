(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{526:function(_,a,v){"use strict";v.r(a);var t=v(2),r=Object(t.a)({},(function(){var _=this,a=_._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[_._v("#")]),_._v(" 设计模式")]),_._v(" "),a("p",[_._v("参考文章:")]),_._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7160363585028227086",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://juejin.cn/post/7160363585028227086"),a("OutboundLink")],1)]),_._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6898207630632681480",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://juejin.cn/post/6898207630632681480"),a("OutboundLink")],1)]),_._v(" "),a("h2",{attrs:{id:"设计模式遵循六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式遵循六大原则"}},[_._v("#")]),_._v(" 设计模式遵循六大原则")]),_._v(" "),a("h3",{attrs:{id:"开闭原则-对扩展开放-对修改关闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则-对扩展开放-对修改关闭"}},[_._v("#")]),_._v(" 开闭原则 -> 对扩展开放，对修改关闭")]),_._v(" "),a("p",[_._v("新增而不是直接修改")]),_._v(" "),a("h3",{attrs:{id:"里氏替换原则-使用基类的地方可以使用子类替换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则-使用基类的地方可以使用子类替换"}},[_._v("#")]),_._v(" 里氏替换原则 -> 使用基类的地方可以使用子类替换")]),_._v(" "),a("p",[_._v("少改父类的方法")]),_._v(" "),a("h3",{attrs:{id:"依赖倒置原则-面向接口编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则-面向接口编程"}},[_._v("#")]),_._v(" 依赖倒置原则 -> 面向接口编程")]),_._v(" "),a("h3",{attrs:{id:"迪米特法则-一个对象对另一个对象应该尽可能少的了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-一个对象对另一个对象应该尽可能少的了解"}},[_._v("#")]),_._v(" 迪米特法则 -> 一个对象对另一个对象应该尽可能少的了解")]),_._v(" "),a("p",[_._v("框架的接口就是这么写的。")]),_._v(" "),a("h3",{attrs:{id:"接口隔离原则-使用多个接口-比使用单个接口要好-没太看懂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-使用多个接口-比使用单个接口要好-没太看懂"}},[_._v("#")]),_._v(" 接口隔离原则 -> 使用多个接口，比使用单个接口要好 没太看懂")]),_._v(" "),a("p",[_._v("多个功能接口，比一个臃肿的完成所有任务的接口要更好使用。")]),_._v(" "),a("h3",{attrs:{id:"单一职责原则-一个类或者接口只完成一件事"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则-一个类或者接口只完成一件事"}},[_._v("#")]),_._v(" 单一职责原则 -> 一个类或者接口只完成一件事")]),_._v(" "),a("p",[_._v("一个页面只完成一个页面的事情，提高自己的抽象能力。")]),_._v(" "),a("h3",{attrs:{id:"合成复用用则-尽量使用对象组合-而不是继承来达到复用的目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成复用用则-尽量使用对象组合-而不是继承来达到复用的目的"}},[_._v("#")]),_._v(" 合成复用用则 -> 尽量使用对象组合，而不是继承来达到复用的目的")]),_._v(" "),a("p",[_._v("声明式ui框架基本都是这个思想")]),_._v(" "),a("h2",{attrs:{id:"常用的设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的设计模式"}},[_._v("#")]),_._v(" 常用的设计模式")]),_._v(" "),a("h3",{attrs:{id:"_1-工厂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-工厂模式"}},[_._v("#")]),_._v(" 1. 工厂模式")]),_._v(" "),a("p",[_._v("**定义：抽象工厂模式会把不同产品子类进行分组，组内不同的产品子类对应同一个工厂子类的不同创建方法，这样就减少了工厂子类的创建\n**")]),_._v(" "),a("p",[_._v("简单工厂模式 -> 工厂方法模式 -> 抽象工厂模式")]),_._v(" "),a("p",[_._v("简单工厂模式，可以通过在工厂内部的代码，进行生成对象。")]),_._v(" "),a("p",[_._v("工厂方法模式，应该多创建类，而不是在工厂里添加冗余的判断，去创建对象。")]),_._v(" "),a("p",[_._v("更进一步，一步步抽象分类，找到要生产对象的特征，进行解耦和组合，就可以得到抽象工厂模式。")]),_._v(" "),a("blockquote",[a("p",[_._v("异：")]),_._v(" "),a("p",[_._v("1、工厂方法模式针对的是单个产品等级结构，而抽象工厂模式针对的是多个产品的等级结构")]),_._v(" "),a("p",[_._v("2、工厂方法模式每个具体的工厂只能创建一种产品对象，而抽象工厂模式的具体工厂能创建多个产品对象")]),_._v(" "),a("p",[_._v("同：")]),_._v(" "),a("p",[_._v("1、工厂方法模式和抽象工厂模式的抽象产品都拥有多个具体地实现产品")]),_._v(" "),a("p",[_._v("2、工厂方法模式和抽象工厂模式的抽象工厂类都有多个具体地实现工厂类")])]),_._v(" "),a("p",[_._v("制作高端产品和低端产品。")]),_._v(" "),a("h3",{attrs:{id:"_2-策略模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-策略模式"}},[_._v("#")]),_._v(" 2.策略模式")]),_._v(" "),a("h4",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[_._v("#")]),_._v(" 定义")]),_._v(" "),a("p",[_._v("定义一系列的算法，并可以实现自由的切换")]),_._v(" "),a("p",[_._v("具体实现，由用户决定。")]),_._v(" "),a("p",[_._v("用户自定义角色技能。")]),_._v(" "),a("h3",{attrs:{id:"_3-状态模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-状态模式"}},[_._v("#")]),_._v(" 3.状态模式")]),_._v(" "),a("h4",{attrs:{id:"状态模式定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态模式定义"}},[_._v("#")]),_._v(" 状态模式定义")]),_._v(" "),a("p",[_._v("对象内部状态的改变会改变其行为**")]),_._v(" "),a("p",[_._v("电视机开关机的例子。")]),_._v(" "),a("p",[_._v("讲的是真的好！")]),_._v(" "),a("h3",{attrs:{id:"_4-代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-代理模式"}},[_._v("#")]),_._v(" 4.代理模式")]),_._v(" "),a("p",[_._v("代理模式主要是使用代理对象劫持原始对象，达到对原始对象的控制")]),_._v(" "),a("p",[_._v("代理模式分为：")]),_._v(" "),a("ol",[a("li",[_._v("静态代理")]),_._v(" "),a("li",[_._v("动态代理")])]),_._v(" "),a("h4",{attrs:{id:"静态代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态代理"}},[_._v("#")]),_._v(" 静态代理")]),_._v(" "),a("p",[_._v("指的就是代理类里面注册了实现类，并且在代理类的方法里在用实现类方法时，插入了自己的方法，完成了对实现类的‘劫持’。")]),_._v(" "),a("h4",{attrs:{id:"动态代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[_._v("#")]),_._v(" 动态代理")]),_._v(" "),a("p",[_._v("jdk动态代理 -> 没有看懂为什么这么写，用到了java的反射")]),_._v(" "),a("p",[_._v("cglib动态代理")]),_._v(" "),a("p",[_._v("区别")]),_._v(" "),a("p",[_._v("可以看到 cglib 动态代理我们主要使用了 Enhancer 工具类以及实现了 MethodInterceptor 接口")]),_._v(" "),a("p",[_._v("Tips:如果被代理类对象实现了接口就使用 JDK 动态代理，否则使用 cglib 动态代理")]),_._v(" "),a("h3",{attrs:{id:"_5-单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-单例模式"}},[_._v("#")]),_._v(" 5.单例模式")]),_._v(" "),a("blockquote",[a("ol",[a("li",[_._v("懒汉式")]),_._v(" "),a("li",[_._v("饿汉式")]),_._v(" "),a("li",[_._v("双重检查式")]),_._v(" "),a("li",[_._v("静态内部类式")]),_._v(" "),a("li",[_._v("枚举式")])])]),_._v(" "),a("p",[a("code",[_._v("单例类会暴露一个公有静态方法，客户端需要调用这个静态方法获取到单例类的唯一对象，在获取这个单例对象的过程中需要确保线程安全，即在多线程环境下构造单例类的对象也是有且只有一个，这也是单例模式实现中比较困难的地方")])]),_._v(" "),a("h4",{attrs:{id:"懒汉式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#懒汉式"}},[_._v("#")]),_._v(" 懒汉式")]),_._v(" "),a("p",[_._v("调用会同步，造成内存损耗")]),_._v(" "),a("h4",{attrs:{id:"饿寒式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#饿寒式"}},[_._v("#")]),_._v(" 饿寒式")]),_._v(" "),a("p",[_._v("不用也生成，增加内存消耗")]),_._v(" "),a("h4",{attrs:{id:"双重检查式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双重检查式"}},[_._v("#")]),_._v(" 双重检查式")]),_._v(" "),a("p",[_._v("多个操作，不是原子操作，高并发下jdk1.5之前会出现问题，执行操作的顺序无法保证")]),_._v(" "),a("p",[_._v("后来官方具体化了volatile关键字，解决了一定的问题")]),_._v(" "),a("h4",{attrs:{id:"静态内部类式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类式"}},[_._v("#")]),_._v(" 静态内部类式")]),_._v(" "),a("p",[_._v("第一次调用 getInstance 方法时才会去加载 Holder 并初始化 INSTANCE，这样既保证了线程的安全也保证了实例的唯一性。")]),_._v(" "),a("h4",{attrs:{id:"枚举式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举式"}},[_._v("#")]),_._v(" 枚举式")]),_._v(" "),a("p",[_._v("默认枚举的实例是线程安全的，并且在任何情况下都是单例，但是这种方式可读性不高。")]),_._v(" "),a("h3",{attrs:{id:"_6-建造者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-建造者模式"}},[_._v("#")]),_._v(" 6.建造者模式")]),_._v(" "),a("p",[_._v("建造者模式主要用来构建对象，将对象的构建与表示进行分离，它更加注重对象的构建过程。")]),_._v(" "),a("p",[_._v("构建一台电脑的过程。")]),_._v(" "),a("h3",{attrs:{id:"_7-原型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-原型模式"}},[_._v("#")]),_._v(" 7.原型模式")]),_._v(" "),a("p",[_._v("原型模式主要用于构建对象，通过拷贝原型对象来创建新的对象，拷贝方式主要分为两种：")]),_._v(" "),a("ol",[a("li",[_._v("浅拷贝")]),_._v(" "),a("li",[_._v("深拷贝")])]),_._v(" "),a("h4",{attrs:{id:"浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[_._v("#")]),_._v(" 浅拷贝")]),_._v(" "),a("p",[_._v("**拷贝一个对象时，如果对象里面的是基本类型，则拷贝的是基本类型的值。如果对象里面是引用类型，则拷贝的是引用类型的地址，此时并没有开辟新的内存空间。\n**")]),_._v(" "),a("h4",{attrs:{id:"深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[_._v("#")]),_._v(" 深拷贝")]),_._v(" "),a("p",[_._v("**拷贝一个对象时，如果对象里面的是基本类型，则拷贝的是基本类型的值，如果对象里面是引用类型，则将引用类型也拷贝一份，此时开辟了新的内存空间\n**")]),_._v(" "),a("h3",{attrs:{id:"_8-适配器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-适配器模式"}},[_._v("#")]),_._v(" 8.适配器模式")]),_._v(" "),a("p",[_._v("适配器模式主要用于适配另外一个不兼容的对象一起工作，主要分 3 种方式：")]),_._v(" "),a("ol",[a("li",[_._v("类适配")]),_._v(" "),a("li",[_._v("对象适配")]),_._v(" "),a("li",[_._v("接口适配")])]),_._v(" "),a("h4",{attrs:{id:"类适配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类适配"}},[_._v("#")]),_._v(" 类适配")]),_._v(" "),a("ol",[a("li",[_._v("定义一个需要被适配的类")]),_._v(" "),a("li",[_._v("定义一个目标接口\n现在我们需要在目标接口的 request 方法中调用 Adaptee 的 adaptee 方法，如何实现呢？")]),_._v(" "),a("li",[_._v("定义一个适配器的类继承要被适配的类和目标接口")])]),_._v(" "),a("h4",{attrs:{id:"对象适配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象适配"}},[_._v("#")]),_._v(" 对象适配")]),_._v(" "),a("ol",[a("li",[_._v("定义一个电压的接口")]),_._v(" "),a("li",[_._v("定义一个220V的实现类")]),_._v(" "),a("li",[_._v("适配器接口，outputDC5V 方法用于将输入的电压变为 5V 后输出")]),_._v(" "),a("li",[_._v("实现电源适配器")])]),_._v(" "),a("h4",{attrs:{id:"接口适配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口适配"}},[_._v("#")]),_._v(" 接口适配")]),_._v(" "),a("p",[_._v("在实际开发中，经常会遇到接口中定义了太多的方法，而有些方法我们是用不到的，此时我们就可以通过适配器模式适配接口")]),_._v(" "),a("h3",{attrs:{id:"_9-装饰着模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-装饰着模式"}},[_._v("#")]),_._v(" 9.装饰着模式")]),_._v(" "),a("p",[_._v("看不懂的蛋炒饭")]),_._v(" "),a("h3",{attrs:{id:"_10-外观模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-外观模式"}},[_._v("#")]),_._v(" 10.外观模式")]),_._v(" "),a("p",[_._v("外观模式主要用于简化系统的使用，它对外提供一个高层接口，并将子系统的功能进行封装")]),_._v(" "),a("p",[_._v("外观模式优点：")]),_._v(" "),a("p",[_._v("1、将对子系统的依赖转换为对外观类的依赖")]),_._v(" "),a("p",[_._v("2、对外部隐藏子系统的具体实现")]),_._v(" "),a("p",[_._v("3、增强了安全性")]),_._v(" "),a("h3",{attrs:{id:"_11-桥接模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-桥接模式"}},[_._v("#")]),_._v(" 11.桥接模式")]),_._v(" "),a("p",[_._v("桥接模式主要用于抽象与实现之间的桥接，实现二者的解耦")]),_._v(" "),a("p",[_._v("例子：画圆形和长方形，并给他们涂上不同的颜色")]),_._v(" "),a("p",[_._v("桥接模式优点：")]),_._v(" "),a("p",[_._v("1、把事物和其具体实现分开，使得他们各自可以独立的变化")]),_._v(" "),a("p",[_._v("2、桥接接口作为你一个维度，抽象类作为一个维度，两者可以随意组合")]),_._v(" "),a("h3",{attrs:{id:"_12-组合模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-组合模式"}},[_._v("#")]),_._v(" 12.组合模式")]),_._v(" "),a("p",[_._v("组合模式的特点就是把一组相似的对象，当作一个单一的对象")]),_._v(" "),a("h3",{attrs:{id:"_13-观察者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-观察者模式"}},[_._v("#")]),_._v(" 13.观察者模式")]),_._v(" "),a("p",[_._v("观察者模式主要用于当一个对象改变，其他对象能收到这种变化")]),_._v(" "),a("p",[_._v("搞了一段kotlin代码，看的迷糊了")]),_._v(" "),a("h3",{attrs:{id:"_14-模版方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-模版方法模式"}},[_._v("#")]),_._v(" 14.模版方法模式")]),_._v(" "),a("p",[_._v("模版方法模式定义了一套算法框架，将一些步骤交由具体的子类去实现")]),_._v(" "),a("p",[_._v("模版方法模式主要有以下角色：")]),_._v(" "),a("ol",[a("li",[_._v("抽象类：定义了一套算法框架")]),_._v(" "),a("li",[_._v("具体实现类")])]),_._v(" "),a("h3",{attrs:{id:"_15-责任链模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-责任链模式"}},[_._v("#")]),_._v(" 15.责任链模式")]),_._v(" "),a("p",[_._v("日志的打点用到了这个责任链模式。")]),_._v(" "),a("h3",{attrs:{id:"_16-解释器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-解释器模式"}},[_._v("#")]),_._v(" 16.解释器模式")]),_._v(" "),a("p",[_._v("解释器模式就是定义一个解释器的规则去解释对象")]),_._v(" "),a("p",[_._v("一脸懵逼……")]),_._v(" "),a("h3",{attrs:{id:"_17-中介者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-中介者模式"}},[_._v("#")]),_._v(" 17.中介者模式")]),_._v(" "),a("p",[_._v("中介者模式主要是通过提供一个中介类来降低多个对象之间的通信复杂度")]),_._v(" "),a("h3",{attrs:{id:"_18-迭代器模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-迭代器模式"}},[_._v("#")]),_._v(" 18.迭代器模式")]),_._v(" "),a("p",[_._v("迭代器模式主要用于顺序访问集合对象的元素，而不需要知道其底层表示")]),_._v(" "),a("p",[_._v("有点看源码的意思。")]),_._v(" "),a("p",[_._v("弹窗的顺序实现感觉是这个模式。")]),_._v(" "),a("h3",{attrs:{id:"_19-享元模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-享元模式"}},[_._v("#")]),_._v(" 19.享元模式")]),_._v(" "),a("p",[_._v("享元模式主要用于减少创建对象的数量，减少内存占用，提高性能。")]),_._v(" "),a("p",[_._v("有点像java里面的集合set，还有redis里面的zset")]),_._v(" "),a("h3",{attrs:{id:"_20-访问者模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-访问者模式"}},[_._v("#")]),_._v(" 20.访问者模式")]),_._v(" "),a("p",[_._v("访问者模式主要就是通过访问者类去访问对象元素并进行相关操作")]),_._v(" "),a("p",[_._v("没理解其中的精髓")]),_._v(" "),a("h3",{attrs:{id:"_21-命令模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-命令模式"}},[_._v("#")]),_._v(" 21.命令模式")]),_._v(" "),a("p",[_._v("命令模式用于给不同的对象下达不同的命令")]),_._v(" "),a("p",[_._v("也是一脸懵，但是可能可以理解。")]),_._v(" "),a("h3",{attrs:{id:"_22-备忘录模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-备忘录模式"}},[_._v("#")]),_._v(" 22.备忘录模式")]),_._v(" "),a("p",[_._v("备忘录模式主要用于保存对象的某个状态，以便在适当的时候恢复对象")])])}),[],!1,null,null,null);a.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{442:function(s,a,t){"use strict";t.r(a);var n=t(2),r=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"gc分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gc分析"}},[s._v("#")]),s._v(" GC分析")]),s._v(" "),a("p",[s._v("学习链接:"),a("a",{attrs:{href:"https://www.yuque.com/aceld/golang/zhzanb",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.yuque.com/aceld/golang/zhzanb"),a("OutboundLink")],1)]),s._v(" "),a("p",[s._v("垃圾回收(Garbage Collection，简称GC)，编程语言提供的自动内存管理机制，自动释放不需要的内存对象，让出存储器资源。gc能力是不同语言性能比较指标之一。")]),s._v(" "),a("h2",{attrs:{id:"go1-3-清除-mark-and-sweep-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-3-清除-mark-and-sweep-算法"}},[s._v("#")]),s._v(" go1.3 - 清除（mark and sweep）算法")]),s._v(" "),a("h3",{attrs:{id:"标记清除算法的具体步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法的具体步骤"}},[s._v("#")]),s._v(" 标记清除算法的具体步骤")]),s._v(" "),a("ol",[a("li",[s._v("暂停程序业务逻辑，分出可达和不可达对象\n"),a("ul",[a("li",[s._v("注意是程序与对象的可达关系")])])]),s._v(" "),a("li",[s._v("程序找出它所有可达的对象，并做上标记")]),s._v(" "),a("li",[s._v("标记完成后，开始清除未标记的对象")]),s._v(" "),a("li",[s._v("停止暂停，程序启动。")]),s._v(" "),a("li",[s._v("循环重复以上过程，直至process程序生命周期结束。")])]),s._v(" "),a("p",[s._v("操作简单。算法执行时，程序暂停（stw: stop the world）。")]),s._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" 缺点")]),s._v(" "),a("ul",[a("li",[s._v("STW，让程序暂停，程序出现卡顿 (重要问题)，cpu不执行代码，全用于垃圾回收")]),s._v(" "),a("li",[s._v("标记需要扫描整个heap")]),s._v(" "),a("li",[s._v("清除数据会产生heap碎片")])]),s._v(" "),a("p",[s._v("GC过程包裹在stw时间内，v1.3做了简单优化，将清除步骤提前，可以不用继续stw了，因为这些对象已经是不可达的了，不会出现回收写冲突等问题。")]),s._v(" "),a("h2",{attrs:{id:"go1-5-三色并发标记法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-5-三色并发标记法"}},[s._v("#")]),s._v(" go1.5 - 三色并发标记法")]),s._v(" "),a("p",[s._v("GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)。")]),s._v(" "),a("p",[s._v("所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些。")]),s._v(" "),a("h3",{attrs:{id:"何为三色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何为三色"}},[s._v("#")]),s._v(" 何为三色")]),s._v(" "),a("p",[s._v("对象分为3种颜色：")]),s._v(" "),a("ul",[a("li",[s._v("白：不确定对象")]),s._v(" "),a("li",[s._v("灰：存活对象，子对象待处理")]),s._v(" "),a("li",[s._v("黑：存活对象")])]),s._v(" "),a("h3",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[s._v("#")]),s._v(" 流程")]),s._v(" "),a("ol",[a("li",[s._v("每次新创建的对象，默认的颜色标记为白色\n"),a("ul",[a("li",[s._v("所谓程序，是一些对象的根节点集合")])])]),s._v(" "),a("li",[s._v("每次GC开始时，会从根节点开始遍历所有对象，把遍历的对象从白色集合放入灰色集合\n"),a("ul",[a("li",[s._v("本次遍历是一次遍历，非递归形式，从程序初次可抵达的对象遍历一层，该次遍历结束后，被遍历到的对象会被标记为灰色。灰色标记表多出这些对象")])])]),s._v(" "),a("li",[s._v("遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，然后将灰色对象放入黑色集合\n"),a("ul",[a("li",[s._v("本次遍历只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色")])])]),s._v(" "),a("li",[s._v("重复第三步，直至灰色集合中没有任何对象")]),s._v(" "),a("li",[s._v("回收所有白色标记表的对象")])]),s._v(" "),a("p",[s._v("以上就是三色并发标记法。")]),s._v(" "),a("p",[s._v("这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。")]),s._v(" "),a("h2",{attrs:{id:"没有stw的三色标记法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有stw的三色标记法"}},[s._v("#")]),s._v(" 没有STW的三色标记法")]),s._v(" "),a("ol",[a("li",[s._v("白色对象被黑色对象引用（白色被挂在黑色下）")]),s._v(" "),a("li",[s._v("灰色对象与它之间的可达关系的白色对象遭到破坏（灰色丢了白色）")])]),s._v(" "),a("p",[s._v("因为对象之间的关系可变，程序可达的对象也可能会被"),a("strong",[s._v("误杀")]),s._v("，")]),s._v(" "),a("h2",{attrs:{id:"屏障机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#屏障机制"}},[s._v("#")]),s._v(" 屏障机制")]),s._v(" "),a("p",[s._v("引出强弱三色不变式")]),s._v(" "),a("ol",[a("li",[s._v("强三色不变式：强制黑色对象不能引用到白色对象的指针")]),s._v(" "),a("li",[s._v("弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态\n"),a("ul",[a("li",[s._v("弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全")])])])]),s._v(" "),a("h3",{attrs:{id:"插入屏障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入屏障"}},[s._v("#")]),s._v(" 插入屏障")]),s._v(" "),a("p",[s._v("具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)")]),s._v(" "),a("p",[s._v("满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色)")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// slot 槽，存储特定类型的数据")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ptr 指针，存储内存地址的值")]),s._v("\n添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" 新下游对象ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("   \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//1")]),s._v("\n  标记灰色"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("新下游对象ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   \n  \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//2")]),s._v("\n  当前下游对象slot "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 新下游对象ptr        \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 场景")]),s._v("\nA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("nil")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" B"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色")]),s._v("\nA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" B"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//A 将下游对象C 更换为B，  B被标记为灰色")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("黑色对象的内存槽有两种位置，栈和堆。")]),s._v(" "),a("p",[s._v("栈空间的特点是容量小，但是要求相应速度快，因为函数调用弹出频繁使用。")]),s._v(" "),a("p",[s._v("所以插入屏障机制，在栈空间的对象操作中不使用，而仅仅使用在堆空间对象的操作中。")]),s._v(" "),a("h4",{attrs:{id:"模拟过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模拟过程"}},[s._v("#")]),s._v(" 模拟过程")]),s._v(" "),a("ol",[a("li",[s._v("程序启动，对象全部标记为白色且放入白色集合中")]),s._v(" "),a("li",[s._v("遍历rootSet，非递归只遍历一次，得到灰色节点")]),s._v(" "),a("li",[s._v("遍历灰色标记表，将可达对象，从白色标记为灰色，遍历之后的灰色节点标记为黑色")]),s._v(" "),a("li",[s._v("由于并发特性，外界向黑色对象1添加白色对象a，黑色对象2添加白色对象b，黑色对象1在堆区，即将触发插入屏障机制，黑色对象2在栈区，为了快速，不触发插入屏障机制。")]),s._v(" "),a("li",[s._v("由于插入写屏障，黑色对象1将白色对象a变为灰色，而白色对象b还是白色")]),s._v(" "),a("li",[s._v("继续上述流程进行三色标记，直至没有灰色节点\n"),a("ul",[a("li",[s._v("如果栈不添加，当全部三色标记扫描之后，栈上有可能依然存在白色对象被引用的情况(如白色对象b)。所以要对栈重新进行三色标记扫描，但这次为了对象不丢失，要对本次标记扫描启动STW暂停。直到栈空间的三色标记结束。")])])]),s._v(" "),a("li",[s._v("在准备回收白色前，重新遍历扫描一次栈空间。此时加STW暂停保护栈，防止外界干扰（新的白色被黑色添加）")]),s._v(" "),a("li",[s._v("在STW中，将栈中的对象依次三色标记，直至没有灰色节点")]),s._v(" "),a("li",[s._v("停止STW，最后将栈和堆空间的白色节点清除，此次STW时间约为10～100ms")])]),s._v(" "),a("h3",{attrs:{id:"删除屏障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除屏障"}},[s._v("#")]),s._v(" 删除屏障")]),s._v(" "),a("p",[s._v("具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。")]),s._v(" "),a("p",[s._v("满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot， 新下游对象ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//1")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot是灰色 "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("||")]),s._v(" 当前下游对象slot是白色"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    标记灰色"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//slot为被删除对象， 标记为灰色")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//2")]),s._v("\n  当前下游对象slot "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 新下游对象ptr\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 场景")]),s._v("\nA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("B"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("nil")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)")]),s._v("\nA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("B"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h4",{attrs:{id:"模拟流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模拟流程"}},[s._v("#")]),s._v(" 模拟流程")]),s._v(" "),a("ol",[a("li",[s._v("程序启动，所有被创建对象标记为白色")]),s._v(" "),a("li",[s._v("非递归遍历RootSet，将可达对象标记为灰色")]),s._v(" "),a("li",[s._v("灰色对象1删除白色对象a，如果不触发删除屏障，白色对象a及其被引用的对象都会被删除")]),s._v(" "),a("li",[s._v("触发删除屏障，白色对象a被标记为灰色")]),s._v(" "),a("li",[s._v("遍历灰色标记表，将可达的白色对象标记为灰色，遍历之后的灰色标记为黑色")]),s._v(" "),a("li",[s._v("循环以上流程，直至灰色标记表没有灰色节点")]),s._v(" "),a("li",[s._v("清除白色节点")])]),s._v(" "),a("p",[s._v("这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。")]),s._v(" "),a("h2",{attrs:{id:"go1-8-混合写屏障-hybrid-write-barrier-机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-8-混合写屏障-hybrid-write-barrier-机制"}},[s._v("#")]),s._v(" go1.8 - 混合写屏障(hybrid write barrier)机制")]),s._v(" "),a("p",[s._v("插入写屏障和删除写屏障的短板：")]),s._v(" "),a("ul",[a("li",[s._v("插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活")]),s._v(" "),a("li",[s._v("删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象")])]),s._v(" "),a("p",[s._v("Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间，结合了两者的优点。")]),s._v(" "),a("h3",{attrs:{id:"混合写屏障规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#混合写屏障规则"}},[s._v("#")]),s._v(" 混合写屏障规则")]),s._v(" "),a("p",[s._v("具体操作:")]),s._v(" "),a("ol",[a("li",[s._v("GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)")]),s._v(" "),a("li",[s._v("GC期间，任何在栈上创建的新对象，均为黑色")]),s._v(" "),a("li",[s._v("被删除的对象标记为灰色")]),s._v(" "),a("li",[s._v("被添加的对象标记为灰色")])]),s._v(" "),a("p",[s._v("满足弱三色不变式。")]),s._v(" "),a("blockquote",[a("p",[s._v("屏障技术是不在栈上应用的，因为要保证栈的运行效率。")])]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[s._v("添加下游对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" 新下游对象ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//1 ")]),s._v("\n  标记灰色"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("当前下游对象slot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//只要当前下游对象被移走，就标记灰色")]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//2 ")]),s._v("\n   标记灰色"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("新下游对象ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//3")]),s._v("\n   当前下游对象slot "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 新下游对象ptr\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"混合写屏障场景分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#混合写屏障场景分析"}},[s._v("#")]),s._v(" 混合写屏障场景分析")]),s._v(" "),a("blockquote",[a("p",[s._v("注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。")])]),s._v(" "),a("p",[s._v("流程：")]),s._v(" "),a("ol",[a("li",[s._v("GC开始时，所有对象都为白色")]),s._v(" "),a("li",[s._v("三色标记法，优先扫描栈区将可达对象全部标记为黑色\n"),a("ul",[a("li",[a("p",[s._v("场景1：对象a被一个堆对象1删除，成为一个栈对象X的下游")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//前提：堆对象1->对象a = 对象a；  //对象a 被 对象1引用")]),s._v("\n栈对象X"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 堆对象a；  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//将堆对象a 挂在 栈对象X 下游")]),s._v("\n堆对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" null；    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//对象1 删除引用 对象a")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("将白色对象a挂在栈对象X下游，因为栈不启动写屏障，所以直接挂在栈对象下")]),s._v(" "),a("li",[s._v("堆对象1删除白色对象a的引用，因为堆对象1在堆中，触发删除写屏障，删除即赋值为null，标记被删除白色对象a为灰色")])])]),s._v(" "),a("li",[a("p",[s._v("场景2：对象被一个堆对象删除引用，成为栈对象的下游")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("new")]),s._v(" 栈对象Y；\n对象Y"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 对象b；      "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//将栈对象b 挂在 栈对象Y 下游")]),s._v("\n对象c"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" null；      "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//对象c 删除引用 对象b")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("新创建一个对象Y在栈上（混合写屏障模式，GC过程中任何新创建的对象标记为黑色）")]),s._v(" "),a("li",[s._v("对象Y添加下游引用栈对象b（直接添加，栈不启动插入写屏障，无屏障效果）")]),s._v(" "),a("li",[s._v("对象c删除对象b的引用关系（直接删除，栈不启动删除写屏障，无屏障效果）")])])]),s._v(" "),a("li",[a("p",[s._v("场景3：对象被一个堆对象删除引用，成为另一个堆对象的下游")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[s._v("堆对象Z"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象N "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 堆对象N； "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//将堆对象N 挂在 堆对象Z 下游")]),s._v("\n堆对象M"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象N "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" null；   "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//对象M 删除引用 对象N")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("堆对象Z已经被扫描标记为黑色")]),s._v(" "),a("li",[s._v("堆对象Z下游添加堆白色对象N，触发插入写屏障机制，被添加的对象标记为灰色，堆白色对象N被标记为灰色")]),s._v(" "),a("li",[s._v("堆对象M删除下游引用堆对象N，触发删除写屏障机制，被删除的对象标记为灰色，堆对象N被标记为为灰色")])])]),s._v(" "),a("li",[a("p",[s._v("场景4：对象从一个栈对象删除引用，成为另一个堆对象的下游")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[s._v("堆对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" 对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("；       "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//将对象3 挂在 堆对象1的下游")]),s._v("\n栈对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("对象"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" null；        "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//栈对象2 删除引用 对象3")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("栈对象2删除栈对象3的引用，栈空间不触发删除写屏障")]),s._v(" "),a("li",[s._v("堆对象1将之前引用对象4的关系，转移至对象3")]),s._v(" "),a("li",[s._v("堆对象删除对象4的引用关系，堆对象删除时，触发写屏障，标记被删除对象4为灰色，保护对象4及下游节点")])])])])])]),s._v(" "),a("p",[s._v("Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW。而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。")]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("GoV1.3 - 普通标记清除法，整体过程需要启动STW，效率极低。")]),s._v(" "),a("p",[s._v("GoV1.5 - 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通")]),s._v(" "),a("p",[s._v("GoV1.8 - 三色标记法，混合写屏障机制，栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。")])])}),[],!1,null,null,null);a.default=r.exports}}]);
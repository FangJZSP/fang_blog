(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{444:function(v,_,a){"use strict";a.r(_);var t=a(2),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"map"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[v._v("#")]),v._v(" map")]),v._v(" "),_("h2",{attrs:{id:"底层原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[v._v("#")]),v._v(" 底层原理")]),v._v(" "),_("p",[v._v("Go中的map是一个指针，占用8个字节，指向hmap结构体。")]),v._v(" "),_("p",[v._v("源码包中src/runtime/map.go定义了hmap的数据结构：")]),v._v(" "),_("p",[v._v("hmap包含若干个结构为bmap的数组。")]),v._v(" "),_("p",[v._v("bmap底层都采用链表结构，bmap通常叫bucket。")]),v._v(" "),_("p",[v._v("一个桶最多8个位置，key被放入一个桶是因为经过hash运算，低B位是通通的，hash的高八位决定key放到桶的哪个位置。")]),v._v(" "),_("p",[v._v("bmap结构静态，编译后会拓展。key value以key和value分别放一起的策略，更节省内存空间。")]),v._v(" "),_("p",[v._v("tophash快速定位key的位置。用key的hash高八位作为tophash的值，tophash不仅能存hash高八位，还能存其他状态。")]),v._v(" "),_("p",[v._v("当map的key和value都不是指针，bmap不包含指针，那么gc不用扫描bmap。")]),v._v(" "),_("p",[v._v("bmap指向溢出桶的字段overflow是uintptr类型，为了防止这些overflow桶被gc掉，所以需要mapextra.overflow将它保存起来。如果bmap的overflow是bmap类型，那么gc扫描的是一个个拉链表，效率明显不如直接扫描一段内存。")]),v._v(" "),_("h2",{attrs:{id:"扩容机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容机制"}},[v._v("#")]),v._v(" 扩容机制")]),v._v(" "),_("h3",{attrs:{id:"负载因子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载因子"}},[v._v("#")]),v._v(" 负载因子")]),v._v(" "),_("p",[v._v("装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数。")]),v._v(" "),_("h3",{attrs:{id:"扩容时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容时机"}},[v._v("#")]),v._v(" 扩容时机")]),v._v(" "),_("p",[v._v("在向"),_("code",[v._v("map")]),v._v("插入新键时，会进行条件检测，符合以下两个条件之一时触发扩容：")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("条件1：超过负载")])]),v._v(" "),_("ul",[_("li",[v._v("当"),_("code",[v._v("map")]),v._v("中的元素个数大于"),_("code",[v._v("6.5 * 桶个数")]),v._v("时，触发扩容。这意味着当"),_("code",[v._v("map")]),v._v("的负载因子过高时，可能会影响查找和插入的效率。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("条件2：溢出桶太多")])]),v._v(" "),_("ul",[_("li",[v._v("当桶总数小于"),_("code",[v._v("2^15")]),v._v("时，如果溢出桶的数量大于或等于桶的总数，则认为溢出桶过多。")]),v._v(" "),_("li",[v._v("当桶总数大于或等于"),_("code",[v._v("2^15")]),v._v("时，如果溢出桶的数量大于或等于"),_("code",[v._v("2^15")]),v._v("，也认为溢出桶太多。")]),v._v(" "),_("li",[v._v("这个条件是对条件1的补充，旨在解决在负载因子较小的情况下，桶的使用率低、查找和插入效率低的问题。")])])])]),v._v(" "),_("h3",{attrs:{id:"扩容机制-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容机制-2"}},[v._v("#")]),v._v(" 扩容机制")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("双倍扩容")])]),v._v(" "),_("ul",[_("li",[v._v("针对条件1，创建一个新的"),_("code",[v._v("buckets")]),v._v("数组，大小为原来的两倍，并将旧的"),_("code",[v._v("buckets")]),v._v("数据搬迁到新的"),_("code",[v._v("buckets")]),v._v("中。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("等量扩容")])]),v._v(" "),_("ul",[_("li",[v._v("针对条件2，不扩大容量，保持"),_("code",[v._v("buckets")]),v._v("数量不变，重新排列键值对，以提高桶的利用率和存取效率。此过程类似于双倍扩容，但不改变桶的数量。")])])])]),v._v(" "),_("h3",{attrs:{id:"扩容函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩容函数"}},[v._v("#")]),v._v(" 扩容函数")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("hashGrow()函数")]),v._v(" "),_("ul",[_("li",[v._v("该函数负责分配新的"),_("code",[v._v("buckets")]),v._v("并将旧的"),_("code",[v._v("buckets")]),v._v("挂到"),_("code",[v._v("oldbuckets")]),v._v("字段上。它并不执行实际的搬迁操作。")])])]),v._v(" "),_("li",[_("strong",[v._v("growMork()函数")]),v._v(" "),_("ul",[_("li",[v._v("该函数负责实际的搬迁操作，将原有的键值对重新分配到新的内存地址。")])])]),v._v(" "),_("li",[_("strong",[v._v("调用时机")]),v._v(" "),_("ul",[_("li",[v._v("在"),_("code",[v._v("mapassign")]),v._v("和"),_("code",[v._v("mapdelete")]),v._v("函数中调用"),_("code",[v._v("growMork()")]),v._v("，即在插入、修改或删除键时，都会尝试进行搬迁操作。首先检查"),_("code",[v._v("oldbuckets")]),v._v("是否已完成搬迁。")])])])]),v._v(" "),_("h3",{attrs:{id:"渐进式搬迁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渐进式搬迁"}},[v._v("#")]),v._v(" 渐进式搬迁")]),v._v(" "),_("ul",[_("li",[v._v("Go语言的"),_("code",[v._v("map")]),v._v("扩容采用渐进式的方式，避免一次性搬迁所有键值对。每次最多只搬迁2个桶，以减少延迟，特别是在存储大量键值对时，这种方式可以有效降低性能影响。")])]),v._v(" "),_("p",[v._v("Go语言的"),_("code",[v._v("map")]),v._v("扩容机制通过负载因子和溢出桶的监测，确保在高效使用内存的同时，保持良好的查找和插入性能。通过双倍扩容和等量扩容的策略，以及渐进式搬迁的方式，优化了"),_("code",[v._v("map")]),v._v("的性能和响应速度。")]),v._v(" "),_("h2",{attrs:{id:"遍历机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#遍历机制"}},[v._v("#")]),v._v(" 遍历机制")]),v._v(" "),_("ol",[_("li",[v._v("随机起始位置")]),v._v(" "),_("li",[v._v("遍历过程中可能出现key搬迁的情况，又是无序的了")])]),v._v(" "),_("h2",{attrs:{id:"非并发安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非并发安全"}},[v._v("#")]),v._v(" 非并发安全")]),v._v(" "),_("p",[v._v("并发读写出现panic")]),v._v(" "),_("h3",{attrs:{id:"如何并发安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何并发安全"}},[v._v("#")]),v._v(" 如何并发安全")]),v._v(" "),_("ol",[_("li",[v._v("读写锁map+sync.RWmutex")]),v._v(" "),_("li",[v._v("sync.map")])]),v._v(" "),_("h2",{attrs:{id:"遍历"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[v._v("#")]),v._v(" 遍历")]),v._v(" "),_("p",[v._v("写保护监测，计算hash，对应桶，是否扩容，是等廓然碗就bucket找新的key，否直接找key，返回key对应指针或空指针")])])}),[],!1,null,null,null);_.default=e.exports}}]);
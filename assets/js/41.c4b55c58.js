(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{451:function(a,t,v){"use strict";v.r(t);var _=v(2),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"消息模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息模块"}},[a._v("#")]),a._v(" 消息模块")]),a._v(" "),t("h2",{attrs:{id:"发送多类型消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送多类型消息"}},[a._v("#")]),a._v(" 发送多类型消息")]),a._v(" "),t("p",[a._v("参考腾讯SDK")]),a._v(" "),t("p",[a._v("发送消息，采用策略+工厂模式")]),a._v(" "),t("h2",{attrs:{id:"发送消息策略优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送消息策略优化"}},[a._v("#")]),a._v(" 发送消息策略优化")]),a._v(" "),t("p",[a._v("父类定义检查和保存的接口，子类实现。")]),a._v(" "),t("p",[a._v("父类完成参数统一校验，消息统一入库。")]),a._v(" "),t("p",[a._v("子类实现检查和保存的接口。子类可以后置更新入库的消息。")]),a._v(" "),t("h2",{attrs:{id:"本地消息表技术方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表技术方案"}},[a._v("#")]),a._v(" 本地消息表技术方案")]),a._v(" "),t("h3",{attrs:{id:"分布式一致性描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式一致性描述"}},[a._v("#")]),a._v(" 分布式一致性描述")]),a._v(" "),t("h4",{attrs:{id:"请求超时如何解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求超时如何解决"}},[a._v("#")]),a._v(" 请求超时如何解决")]),a._v(" "),t("p",[a._v("极端情况，数据库数据更新成功，但是返回给前端的过程超时。")]),a._v(" "),t("p",[a._v("返回的结果可能延迟，可能丢失，但是不可能出错。")]),a._v(" "),t("p",[a._v("对于超时的请求，是一种不确定的状态。可以追加一个定时任务重试。")]),a._v(" "),t("p",[a._v("有了重试，就一定要保证幂等。")]),a._v(" "),t("p",[a._v("Ps:不仅仅是微服务会出现分布式一致性的问题。哪怕你是个单体项目，你也需要操作redis，发送MQ。只要是对于第三方的操作，本地事务就无法保证这种分布式下的一致性问题。")]),a._v(" "),t("h4",{attrs:{id:"本地消息表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表"}},[a._v("#")]),a._v(" 本地消息表")]),a._v(" "),t("p",[a._v("常见的分布式事务tcc，2pc，3pc，本地消息表。")]),a._v(" "),t("h5",{attrs:{id:"前提描述-期待完成的结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前提描述-期待完成的结果"}},[a._v("#")]),a._v(" 前提描述&期待完成的结果")]),a._v(" "),t("p",[a._v("由于网络的不可靠性，会出现本地成功了，但是第三方可能网络波动，没有执行成功。")]),a._v(" "),t("p",[a._v("但我们需要确保本地的操作和第三方操作保证一致。要么都成功，要么都失败。")]),a._v(" "),t("p",[a._v("事务消息保证的就是第三方一定要执行成功，达到最终一致性。")]),a._v(" "),t("h5",{attrs:{id:"解决思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决思路"}},[a._v("#")]),a._v(" 解决思路")]),a._v(" "),t("p",[a._v("把对第三方的操作，都变成一条本地的记录和我们的本地事务一起入库。这样就保证了持久化，至少该操作不会丢失。")]),a._v(" "),t("p",[a._v("然后通过定时任务来保证这条操作一定会被执行成功，如果一次遇到网络波动，返回超时，没有关系。")]),a._v(" "),t("p",[a._v("定时任务会一直查出来，最终返回一个确定的结果（成功或失败）。")]),a._v(" "),t("p",[a._v("这时候就可以删除这条操作明细了。保证了最终一致性。")]),a._v(" "),t("h5",{attrs:{id:"实现过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现过程"}},[a._v("#")]),a._v(" 实现过程")]),a._v(" "),t("p",[a._v("无论是任何对第三方的操作，对应的java代码中，不过都是执行一个方法而已。\n那我们存的本地消息表，就可以高度抽象成对方法的执行，确保某个方法执行成功。")]),a._v(" "),t("ul",[t("li",[a._v("类型：统一操作java方法")]),a._v(" "),t("li",[a._v("操作参数：方法的入参。")])]),a._v(" "),t("h5",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[a._v("#")]),a._v(" 思考")]),a._v(" "),t("ol",[t("li",[a._v("在框架级别做到把操作记录和事务一起入库?")]),a._v(" "),t("li",[a._v("怎么去定时的重试?")]),a._v(" "),t("li",[a._v("怎么重新执行到java对应位置的方法?")])]),a._v(" "),t("h2",{attrs:{id:"本地消息表实现框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表实现框架"}},[a._v("#")]),a._v(" 本地消息表实现框架")]),a._v(" "),t("h2",{attrs:{id:"集群推送实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群推送实现"}},[a._v("#")]),a._v(" 集群推送实现")])])}),[],!1,null,null,null);t.default=s.exports}}]);
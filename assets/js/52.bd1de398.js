(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{460:function(a,t,s){"use strict";s.r(t);var e=s(2),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"mq高级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mq高级"}},[a._v("#")]),a._v(" MQ高级")]),a._v(" "),t("p",[a._v("三个可靠性，发送者，消费者，")]),a._v(" "),t("h2",{attrs:{id:"发送者可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送者可靠性"}},[a._v("#")]),a._v(" 发送者可靠性")]),a._v(" "),t("h3",{attrs:{id:"发送者重连"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送者重连"}},[a._v("#")]),a._v(" 发送者重连")]),a._v(" "),t("p",[a._v("通过yml文件配置，可以开启连接失败后的重试机制")]),a._v(" "),t("p",[a._v("这个重试机制是阻塞式的，会影响发送消息代码下面的代码")]),a._v(" "),t("h3",{attrs:{id:"发送者确认机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送者确认机制"}},[a._v("#")]),a._v(" 发送者确认机制")]),a._v(" "),t("p",[a._v("提供了发送者确认和返回两种机制。")]),a._v(" "),t("p",[a._v("开启确认机制后，发送消息给MQ后，会返回确认结果给后者。")]),a._v(" "),t("p",[a._v("返回结果如下：")]),a._v(" "),t("ul",[t("li",[a._v("消息投递到MQ，但是路由失败。会返回路由异常原因，然后返回ACK，告知投递成功")]),a._v(" "),t("li",[a._v("临时消息投递到MQ，并且入队成功，返回ACK，告知投递成功")]),a._v(" "),t("li",[a._v("持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功")]),a._v(" "),t("li",[a._v("其他情况下都会返回NACK，告知投递失败（没到交换机/没到队列/到队列没有持久化/……）")])]),a._v(" "),t("h4",{attrs:{id:"确认机制实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确认机制实现"}},[a._v("#")]),a._v(" 确认机制实现")]),a._v(" "),t("p",[a._v("1.添加配置文件")]),a._v(" "),t("div",{staticClass:"language-yml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("spring")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("rabbitmq")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("publisher-confirm-type")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" correlated "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 开启publisher confirm机制，并设置confirm类型")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("publisher-returns")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean important"}},[a._v("true")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 开启publisher return机制")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("这里publisher-confirm-type有三种模式可选：")]),a._v(" "),t("ul",[t("li",[a._v("none：关闭confirm机制")]),a._v(" "),t("li",[a._v("simple：同步阻塞等待MQ的回执")]),a._v(" "),t("li",[a._v("correlated：MQ异步回调返回回执")])]),a._v(" "),t("p",[a._v("2.每个RabbitTemplate只能配置一个ReturnCallBack，项目启动过程中配置")]),a._v(" "),t("p",[a._v("3.发送消息，指定消息ID、消息ConfirmCallback")]),a._v(" "),t("p",[a._v("future代表将来的结果，果然编程语言都是互相借鉴来借鉴去的。")]),a._v(" "),t("p",[a._v("通过回调函数的形式，完成对结果的处理～")]),a._v(" "),t("h3",{attrs:{id:"发送者确认的代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送者确认的代码实现"}},[a._v("#")]),a._v(" 发送者确认的代码实现")]),a._v(" "),t("ol",[t("li",[a._v("修改配置文件")]),a._v(" "),t("li",[a._v("config目录下 添加MqConfig 添加我们的配置～")]),a._v(" "),t("li",[a._v("定义ReturnCallback（只能配置一个，项目启动过程中配置）和ConfirmCallback（发送消息，指定消息ID、消息ConfirmCallback）")])]),a._v(" "),t("p",[a._v("测试： 测试方法 没有充足的时间等待回执，所以可以小小的睡眠一下")]),a._v(" "),t("p",[a._v("在回调方法里面可以重发一次消息～ 不过回调的次数应该有上限")]),a._v(" "),t("h4",{attrs:{id:"关于配置类的思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于配置类的思考"}},[a._v("#")]),a._v(" 关于配置类的思考？")]),a._v(" "),t("p",[a._v("我的理解：")]),a._v(" "),t("p",[a._v("添加了@Configuration注解，在代码启动后，配置类会生成实例，存储在进程中，当进程中出现了某些需要该实例完成的任务，实例中的对应方法就会对该任务进行处理。")]),a._v(" "),t("p",[t("strong",[a._v("gpt")]),a._v("解答如下：")]),a._v(" "),t("p",[a._v("你的理解基本准确，不过为了更清晰地理解@Configuration注解的作用，我们可以再详细细化一下：\n@Configuration注解是Spring框架中的一个标识，用于标记一个类作为Bean的配置源，也就是这个类会定义创建Bean的方法。")]),a._v(" "),t("ol",[t("li",[a._v("在Spring的应用上下文中定义的Bean，可以包含各种类型数据：连接串，服务类，数据源等。这些Bean可以在你的应用中的任何位置使用。")]),a._v(" "),t("li",[a._v("标记为@Configuration的类通常会包含一个或多个标记为@Bean的方法。这些方法将会被Spring容器调用，并注册这些方法返回的对象为Spring容器管理的Bean。")]),a._v(" "),t("li",[a._v("当有其他地方需要这些Bean时（如通过@Autowired注解或容器的getBean()方法），Spring容器就会找到对应的方法来创建并提供这个Bean。这就意味着，每当我们需要一个由@Configuration类创建的Bean时，Spring容器会确保该Bean已经创建并初始化好。")])]),a._v(" "),t("p",[a._v("所以说，@Configuration标注的类等同于一个Spring XML配置文件，它的主要作用是定义和提供新的Spring Bean。当你在项目中需要使用到这个Bean时，Spring就会去调用@Configuration类中的对应方法来实例化这个Bean，然后注入到项目中需要的地方。")]),a._v(" "),t("h2",{attrs:{id:"mq可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mq可靠性"}},[a._v("#")]),a._v(" MQ可靠性")]),a._v(" "),t("p",[a._v("默认情况下，存到内存中，降低消息收发的延迟。")]),a._v(" "),t("ul",[t("li",[a._v("一旦MQ宕机，内存中的消息会丢失")]),a._v(" "),t("li",[a._v("内存空间有限，消费者故障或处理过慢，会导致消息积压，引发MQ阻塞")])]),a._v(" "),t("h3",{attrs:{id:"数据持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据持久化"}},[a._v("#")]),a._v(" 数据持久化")]),a._v(" "),t("ul",[t("li",[a._v("交换机持久化（默认开启）")]),a._v(" "),t("li",[a._v("队列持久化")]),a._v(" "),t("li",[a._v("消息持久化（投递模式：持久化/非持久化）")])]),a._v(" "),t("p",[a._v("哪怕MQ重启，消息也不会丢失～")]),a._v(" "),t("h4",{attrs:{id:"开始测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开始测试"}},[a._v("#")]),a._v(" 开始测试")]),a._v(" "),t("p",[a._v("构建单元测试，默认发送的消息是持久化的，所以需要我们自己构建Message实例，设置为非持久化，并测试性能～")]),a._v(" "),t("p",[a._v("关闭确认机制，否则性能较差。")]),a._v(" "),t("p",[a._v("这个时间是不是和磁盘的写数据能力有关系，有些人内存比磁盘快～ hh")]),a._v(" "),t("h3",{attrs:{id:"lazyqueue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lazyqueue"}},[a._v("#")]),a._v(" LazyQueue")]),a._v(" "),t("p",[a._v("惰性队列：")]),a._v(" "),t("ul",[t("li",[a._v("接收到消息后直接存入磁盘而非内存")]),a._v(" "),t("li",[a._v("消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）")]),a._v(" "),t("li",[a._v("支持数百万条的消息存储")])]),a._v(" "),t("h4",{attrs:{id:"设置懒加载队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置懒加载队列"}},[a._v("#")]),a._v(" 设置懒加载队列")]),a._v(" "),t("p",[a._v("只需要在声明队列时，执行x-queue-mode属性为lazy就行")]),a._v(" "),t("h2",{attrs:{id:"消费者可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者可靠性"}},[a._v("#")]),a._v(" 消费者可靠性")]),a._v(" "),t("h3",{attrs:{id:"消费者确认机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者确认机制"}},[a._v("#")]),a._v(" 消费者确认机制")]),a._v(" "),t("p",[a._v("当消费者处理消息结束后，给消息队列发送一个回执，告知消息队列自己消息的处理状态。")]),a._v(" "),t("ul",[t("li",[a._v("ack：成功处理消息，消息队列删除该消息")]),a._v(" "),t("li",[a._v("nack：消息处理失败，消息队列需要再次投递消息")]),a._v(" "),t("li",[a._v("reject：消息处理失败并拒绝该消息，消息队列删除该消息")])]),a._v(" "),t("h4",{attrs:{id:"配置文件选择ack处理方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置文件选择ack处理方式"}},[a._v("#")]),a._v(" 配置文件选择ACK处理方式")]),a._v(" "),t("p",[a._v("通过配置文件设置ACK处理方式，有三种模式：")]),a._v(" "),t("ul",[t("li",[a._v("none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用")]),a._v(" "),t("li",[a._v("manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活")]),a._v(" "),t("li",[a._v("auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：\n"),t("ul",[t("li",[a._v("如果是业务异常，会自动返回nack；")]),a._v(" "),t("li",[a._v("如果是消息处理或校验异常，自动返回reject;")])])])]),a._v(" "),t("div",{staticClass:"language-yml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("spring")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("rabbitmq")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("listener")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("simple")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("acknowledge-mode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" none "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 不做处理")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("h3",{attrs:{id:"消费者重试策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者重试策略"}},[a._v("#")]),a._v(" 消费者重试策略")]),a._v(" "),t("p",[a._v("在消费者出现异常时利用本地重试，而不是重复添加到队列。")]),a._v(" "),t("div",{staticClass:"language-yml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-yml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("spring")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("rabbitmq")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("listener")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("simple")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("retry")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n          "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("enabled")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean important"}},[a._v("true")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 开启消费者失败重试")]),a._v("\n          "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("initial-interval")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" 1000ms "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 初识的失败等待时长为1秒")]),a._v("\n          "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("multiplier")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 失败的等待时长倍数，下次等待时长 = multiplier * last-interval")]),a._v("\n          "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("max-attempts")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 最大重试次数")]),a._v("\n          "),t("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("stateless")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean important"}},[a._v("true")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# true无状态；false有状态。如果业务中包含事务，这里改为false")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("h4",{attrs:{id:"失败消息处理策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#失败消息处理策略"}},[a._v("#")]),a._v(" 失败消息处理策略")]),a._v(" "),t("p",[a._v("Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：")]),a._v(" "),t("ul",[t("li",[a._v("RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式")]),a._v(" "),t("li",[a._v("ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队")]),a._v(" "),t("li",[a._v("RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机")])]),a._v(" "),t("p",[a._v("比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。")]),a._v(" "),t("h5",{attrs:{id:"实现失败消息处理策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现失败消息处理策略"}},[a._v("#")]),a._v(" 实现失败消息处理策略")]),a._v(" "),t("p",[a._v("代码实现")]),a._v(" "),t("h3",{attrs:{id:"业务幂等处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#业务幂等处理"}},[a._v("#")]),a._v(" 业务幂等处理")]),a._v(" "),t("p",[a._v("在同一个业务，执行一次或多次对业务状态是一致的。")]),a._v(" "),t("p",[a._v("天生幂等 vs 非幂等")]),a._v(" "),t("h4",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),t("p",[a._v("1.消息唯一id")]),a._v(" "),t("ul",[t("li",[a._v("每一条消息都生成一个唯一的id，与消息一起投递给消费者。")]),a._v(" "),t("li",[a._v("消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库")]),a._v(" "),t("li",[a._v("如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。")])]),a._v(" "),t("p",[a._v("2.业务判断")]),a._v(" "),t("h2",{attrs:{id:"延迟消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#延迟消息"}},[a._v("#")]),a._v(" 延迟消息")]),a._v(" "),t("h3",{attrs:{id:"什么是延迟消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是延迟消息"}},[a._v("#")]),a._v(" 什么是延迟消息")]),a._v(" "),t("p",[a._v("延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。")]),a._v(" "),t("p",[a._v("延迟任务：设置一定时间之后才执行的任务。")]),a._v(" "),t("h3",{attrs:{id:"死信交换机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死信交换机"}},[a._v("#")]),a._v(" 死信交换机")]),a._v(" "),t("p",[a._v("当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：")]),a._v(" "),t("ul",[t("li",[a._v("消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false")]),a._v(" "),t("li",[a._v("消息是一个过期消息，超时无人消费")]),a._v(" "),t("li",[a._v("要投递的队列消息满了，无法投递")])]),a._v(" "),t("p",[a._v("通过dead——letter-exchange交换机，队列中的死信就会投递到这个交换机中。这个交换机就叫死信交换机。")]),a._v(" "),t("p",[a._v("设置一个交换机但没有绑定消费者就会进行等待，就会投递到死信交换机。")]),a._v(" "),t("h3",{attrs:{id:"延迟消息插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#延迟消息插件"}},[a._v("#")]),a._v(" 延迟消息插件")]),a._v(" "),t("p",[a._v("这个插件可以将普通交换机改造成支持延迟消息功能的交换机。")]),a._v(" "),t("ul",[t("li",[a._v("注解实现")]),a._v(" "),t("li",[a._v("Bean的实现")])]),a._v(" "),t("p",[a._v("消息头设置x-delay，延迟的时间不要太长，可能会在cpu存在的时间很长，对cpu的压力会很大。")]),a._v(" "),t("h3",{attrs:{id:"取消超时订单"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#取消超时订单"}},[a._v("#")]),a._v(" 取消超时订单")])])}),[],!1,null,null,null);t.default=r.exports}}]);
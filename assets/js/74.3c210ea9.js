(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{483:function(a,t,r){"use strict";r.r(t);var s=r(2),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"消息队列问题汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列问题汇总"}},[a._v("#")]),a._v(" 消息队列问题汇总")]),a._v(" "),t("h2",{attrs:{id:"为什么使用消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列"}},[a._v("#")]),a._v(" 为什么使用消息队列")]),a._v(" "),t("p",[a._v("解耦 异步 削峰")]),a._v(" "),t("h2",{attrs:{id:"如何保证消息队列的高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息队列的高可用"}},[a._v("#")]),a._v(" 如何保证消息队列的高可用")]),a._v(" "),t("p",[a._v("高可用")]),a._v(" "),t("h2",{attrs:{id:"如何保证消息不被重复消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息不被重复消费"}},[a._v("#")]),a._v(" 如何保证消息不被重复消费")]),a._v(" "),t("p",[a._v("保证消息消费的幂等性")]),a._v(" "),t("h2",{attrs:{id:"如何保证消息的可靠性传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息的可靠性传输"}},[a._v("#")]),a._v(" 如何保证消息的可靠性传输")]),a._v(" "),t("p",[a._v("处理消息丢失的问题，")]),a._v(" "),t("p",[a._v("Kafka/RabbitMQ")]),a._v(" "),t("h3",{attrs:{id:"生产者丢失了消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生产者丢失了消息"}},[a._v("#")]),a._v(" 生产者丢失了消息")]),a._v(" "),t("ul",[t("li",[a._v("RabbitMQ消息队列的事物机制")]),a._v(" "),t("li",[a._v("confirm机制")])]),a._v(" "),t("p",[a._v("事物机制是同步的，而confirm机制是异步的")]),a._v(" "),t("h3",{attrs:{id:"消息队列丢失了消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列丢失了消息"}},[a._v("#")]),a._v(" 消息队列丢失了消息")]),a._v(" "),t("p",[a._v("RabbitMQ开启持久化")]),a._v(" "),t("p",[a._v("持久化可以和confirm机制结合，只有返回了ack，才能认为消息被持久化到磁盘")]),a._v(" "),t("h3",{attrs:{id:"消费者丢失了消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消费者丢失了消息"}},[a._v("#")]),a._v(" 消费者丢失了消息")]),a._v(" "),t("p",[a._v("关闭RabbitMQ的自动ack，自己调用ack通知消费成功")]),a._v(" "),t("h2",{attrs:{id:"如何保证消息的顺序性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息的顺序性"}},[a._v("#")]),a._v(" 如何保证消息的顺序性")]),a._v(" "),t("p",[a._v("异常：")]),a._v(" "),t("ul",[t("li",[a._v("消费者消费的顺序不一样")]),a._v(" "),t("li",[a._v("多线程并发处理消息，顺序可能乱；单线程处理，吞吐量较低")])]),a._v(" "),t("h2",{attrs:{id:"如何解决消息队列的延时以及过期失效问题-消息队列满了以后该怎么处理-有几百万消息持续积压几小时-说说怎么解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决消息队列的延时以及过期失效问题-消息队列满了以后该怎么处理-有几百万消息持续积压几小时-说说怎么解决"}},[a._v("#")]),a._v(" 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？")]),a._v(" "),t("h3",{attrs:{id:"大量消息积压解决思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大量消息积压解决思路"}},[a._v("#")]),a._v(" 大量消息积压解决思路")]),a._v(" "),t("ul",[t("li",[a._v("先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。")]),a._v(" "),t("li",[a._v("新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。")]),a._v(" "),t("li",[a._v("然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。")]),a._v(" "),t("li",[a._v("接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。")]),a._v(" "),t("li",[a._v("等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。")])]),a._v(" "),t("h3",{attrs:{id:"消息队列中消息过期失效了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列中消息过期失效了"}},[a._v("#")]),a._v(" 消息队列中消息过期失效了")]),a._v(" "),t("p",[a._v("消息大量过期，也可能是消息大量丢失。")]),a._v(" "),t("p",[a._v("手动把消息查出来，加到消息队列中")]),a._v(" "),t("h3",{attrs:{id:"消息队列中的消息堆满了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列中的消息堆满了"}},[a._v("#")]),a._v(" 消息队列中的消息堆满了")]),a._v(" "),t("p",[a._v("临时写程序，接入数据消费，消费一个丢弃一个，然后到晚上再补救数据")]),a._v(" "),t("h2",{attrs:{id:"如何设计一个消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一个消息队列"}},[a._v("#")]),a._v(" 如何设计一个消息队列")]),a._v(" "),t("p",[a._v("可以看看nsq如何设计的")])])}),[],!1,null,null,null);t.default=v.exports}}]);
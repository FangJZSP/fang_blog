(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{485:function(a,t,v){"use strict";v.r(t);var _=v(2),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[a._v("#")]),a._v(" 消息队列")]),a._v(" "),t("h2",{attrs:{id:"前置知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置知识"}},[a._v("#")]),a._v(" 前置知识")]),a._v(" "),t("h3",{attrs:{id:"消息队列的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的作用"}},[a._v("#")]),a._v(" 消息队列的作用")]),a._v(" "),t("p",[a._v("异步 解耦 -> 削峰")]),a._v(" "),t("p",[a._v("削峰是进阶")]),a._v(" "),t("p",[a._v("消息队列，解耦复杂业务，降低返回时间")]),a._v(" "),t("h3",{attrs:{id:"使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景")]),a._v(" "),t("p",[a._v("日志处理和消息通讯")]),a._v(" "),t("h2",{attrs:{id:"面试准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试准备"}},[a._v("#")]),a._v(" 面试准备")]),a._v(" "),t("h3",{attrs:{id:"问答场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问答场景"}},[a._v("#")]),a._v(" 问答场景")]),a._v(" "),t("ul",[t("li",[a._v("是否使用消息队列？解决什么场景问题？")]),a._v(" "),t("li",[a._v("不使用消息队列是否可行？和使用消息队列比较有何优缺点？")]),a._v(" "),t("li",[a._v("使用的什么消息队列？该消息队列的优缺点？")]),a._v(" "),t("li",[a._v("是否听说过延迟队列？怎么实现延迟队列？")]),a._v(" "),t("li",[a._v("如何设计秒杀架构？什么是事件驱动架构？")])]),a._v(" "),t("blockquote",[t("p",[a._v("三种特性，异步解耦削峰")])]),a._v(" "),t("h2",{attrs:{id:"基本思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本思路"}},[a._v("#")]),a._v(" 基本思路")]),a._v(" "),t("h3",{attrs:{id:"秒杀场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#秒杀场景"}},[a._v("#")]),a._v(" 秒杀场景")]),a._v(" "),t("ul",[t("li",[a._v("在消息队列之前，要对用户请求做一些校验，比如说这个用户是否已经参加过秒杀了。")]),a._v(" "),t("li",[a._v("其次要扣库存，扣库存成功才算是抢到了。")]),a._v(" "),t("li",[a._v("紧接着就是把这个请求丢到消息队列里，后续异步创建订单，并且完成支付。")])]),a._v(" "),t("p",[a._v("那么这种设计的精髓就是利用消息队列把整个秒杀过程分成轻重两个部分。")]),a._v(" "),t("ul",[t("li",[a._v("在进入消息队列之前的操作都是轻量级的，一般也就是内存计算或者访问一些Redis，所以你可以认为瓶颈基本上取决于Redis的性能。")]),a._v(" "),t("li",[a._v("而进入消息队列之后就是非常重量级的操作了，比如说要进一步验证交易的合法性，操作数据库等。")])]),a._v(" "),t("h3",{attrs:{id:"订单超时取消"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#订单超时取消"}},[a._v("#")]),a._v(" 订单超时取消")]),a._v(" "),t("h2",{attrs:{id:"亮点方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#亮点方案"}},[a._v("#")]),a._v(" 亮点方案")]),a._v(" "),t("h3",{attrs:{id:"为什么一定要使用消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么一定要使用消息队列"}},[a._v("#")]),a._v(" 为什么一定要使用消息队列")]),a._v(" "),t("ul",[t("li",[a._v("为什么订单服务不直接调用各个业务方呢？")]),a._v(" "),t("li",[a._v("为什么服务端不直接把消息转发给各个接收者呢？")])]),a._v(" "),t("p",[a._v("本质上在问：业务场景下，不异步、不解耦或者不削峰会有什么问题？")]),a._v(" "),t("p",[a._v("同步调用相比引入消息队列有三大缺陷：")]),a._v(" "),t("ul",[t("li",[a._v("性能差（不并发需要串行等到所有业务返回，并且业务不能失败）")]),a._v(" "),t("li",[a._v("扩展性差（相比消息队列，下游只需要自己去订阅消息队列的消息就可以认为是成功了；）")]),a._v(" "),t("li",[a._v("可用性差（相比消息队列，发送到消息队列就可以认为是成功了）")])]),a._v(" "),t("p",[a._v("并发性能没有交给消息队列快，而且并发也取决于业务的最慢的一个环节。")]),a._v(" "),t("p",[a._v("即便并发解决了，但是扩展性和可用性也不是很好。")]),a._v(" "),t("h3",{attrs:{id:"如果一定不能用消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果一定不能用消息队列"}},[a._v("#")]),a._v(" 如果一定不能用消息队列")]),a._v(" "),t("p",[a._v("提供一个一致性的抽象来减轻这种接入的负担")]),a._v(" "),t("h3",{attrs:{id:"事件驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[a._v("#")]),a._v(" 事件驱动")])])}),[],!1,null,null,null);t.default=s.exports}}]);
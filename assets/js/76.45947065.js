(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{484:function(a,_,v){"use strict";v.r(_);var t=v(2),e=Object(t.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"kafka支持延迟消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka支持延迟消息"}},[a._v("#")]),a._v(" Kafka支持延迟消息")]),a._v(" "),_("h2",{attrs:{id:"延迟队列和延迟消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#延迟队列和延迟消息"}},[a._v("#")]),a._v(" 延迟队列和延迟消息")]),a._v(" "),_("h3",{attrs:{id:"延迟队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#延迟队列"}},[a._v("#")]),a._v(" 延迟队列")]),a._v(" "),_("p",[a._v("延迟队列是一种特殊的队列，它里面的每个元素都有一个过期时间，当元素还没到过期时间的时候，如果你试图从队列里面获取一个元素，你会被阻塞；当有元素过期的时候，你就会拿到这个过期的元素。可以这样想，拿到的永远是最先过期的那个元素")]),a._v(" "),_("h3",{attrs:{id:"延迟消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#延迟消息"}},[a._v("#")]),a._v(" 延迟消息")]),a._v(" "),_("p",[a._v("基于消息队列的延迟队列，也叫做延迟消息。")]),a._v(" "),_("p",[a._v("具体来说，延迟消息是指消息不是立刻被消费的，而是在经过一段时间之后，才会被消费。")]),a._v(" "),_("p",[a._v("在到时间之前，这个消息一直都被存储在消息队列的服务器上。")]),a._v(" "),_("p",[a._v("订单超时取消的例子，它就用到了延迟消息。")]),a._v(" "),_("h2",{attrs:{id:"支持延迟消息的其他消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#支持延迟消息的其他消息队列"}},[a._v("#")]),a._v(" 支持延迟消息的其他消息队列")]),a._v(" "),_("p",[a._v("RabbitMQ有插件支持延迟消息功能，而RocketMQ和Kafka则只能自己开发。")]),a._v(" "),_("h3",{attrs:{id:"rabbitmq延迟消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq延迟消息"}},[a._v("#")]),a._v(" RabbitMQ延迟消息")]),a._v(" "),_("p",[_("code",[a._v("rabbitmq_delayed_message_exchange")]),a._v("启用这个插件就可以使用延迟消息。")]),a._v(" "),_("p",[a._v("这个插件的基本原理也比较简单，就是实现了一个exchange。")]),a._v(" "),_("p",[a._v("这个exchange控制消息什么时候会被真的投递到队列里，消息暂存exchange里，使用Mnesia来存储当延迟的时间满足条件之后，存储的消息会投递到真正的消息队列。")]),a._v(" "),_("p",[a._v("启发：")]),a._v(" "),_("ul",[_("li",[a._v("实现一个延迟队列可以借助数据库")])]),a._v(" "),_("p",[a._v("限制：")]),a._v(" "),_("ul",[_("li",[a._v("消息在投递到目标消息队列之前，存放在服务端本地的Mnesia，如果这时候没有刷新磁盘或节点不可用，消息可能丢失")]),a._v(" "),_("li",[a._v("不支持高并发、大数据量，现实中很多场景都是要在高并发大数据量场景下使用延迟消息")])]),a._v(" "),_("p",[a._v("除此之外，利用rabbitMQ的ttl功能和死信队列，可手动实现延迟消息。")]),a._v(" "),_("p",[a._v("死信队列是一种逻辑上的概念，也就是说它本身只是一个普通的队列。而死信的意思是指过期的无法被消费的消息，这些消息会被投送到这个死信队列。")]),a._v(" "),_("p",[a._v("开发者准备一个队列delay_queue，为这个delay_queue设置过期时间，这个delay_queue不需要消费者。然后把你真实的业务biz_queue绑定到这个delay_queue，作为它的死信队列。")]),a._v(" "),_("p",[a._v("生产者发送消息到delay_queue，因为没有消费这，所以消息会过期。过期之后的消息被转发到死信队列，也就是biz_queue里面，这样消费者就能拿到消息了。")]),a._v(" "),_("p",[a._v("但是ttl的设置是在队列级别上的，可能需要设置多个不同ttl的队列来满足业务需求。")]),a._v(" "),_("h2",{attrs:{id:"面试准备"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试准备"}},[a._v("#")]),a._v(" 面试准备")]),a._v(" "),_("p",[a._v("弄清楚自己的项目")]),a._v(" "),_("ol",[_("li",[a._v("有没有使用延迟消息的场景")]),a._v(" "),_("li",[a._v("消息中间件支不支持延迟消息")]),a._v(" "),_("li",[a._v("延迟消息的QPS有多高，消息量有多大？延迟时间有多长？")])]),a._v(" "),_("p",[a._v("话题引导")]),a._v(" "),_("ol",[_("li",[a._v("讨论延迟消息如何实现，以及业务场景")]),a._v(" "),_("li",[a._v("聊kafka，介绍优缺点，从不支持延迟队列的缺点，引导面试官问你kafka如果支持延迟队列应该怎么做")]),a._v(" "),_("li",[a._v("如果用的不是kafka，强调其他选型和kafka的区别，考虑到不支持所以选择了其他")])]),a._v(" "),_("h2",{attrs:{id:"基础思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础思路"}},[a._v("#")]),a._v(" 基础思路")]),a._v(" "),_("h3",{attrs:{id:"利用定时任务调度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#利用定时任务调度"}},[a._v("#")]),a._v(" 利用定时任务调度")]),a._v(" "),_("p",[a._v("假设一个延迟消息需要延迟30分钟后才可以被消费。那么可以设定定时任务，该任务会在30分钟后将消息发送到消息服务器上。")]),a._v(" "),_("blockquote",[_("p",[a._v("最简单的做法就是利用已经解决了持久化的分布式任务平台。那么业务发送者就相当于注册一个任务，这个任务就是在30min后将消息发送到kafka上。这样消费者就能消费了。")]),a._v(" "),_("p",[a._v("这个方案的缺点就是无法支持高并发。绝大多数的定时任务都没有办法支撑住高并发、大数据的定时任务调度。所以只有应用规模小，延迟消息不多的情况下，考虑使用该方案。如果想支持高并发、大数据的延迟方案，还要考虑利用消息队列。")])]),a._v(" "),_("h3",{attrs:{id:"分区设置不同的延迟时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分区设置不同的延迟时间"}},[a._v("#")]),a._v(" 分区设置不同的延迟时间")]),a._v(" "),_("p",[a._v("根据延迟来选择partition。")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("          delay_topic       延迟消费组\n       -    p0 - 1m    -      消费组1\n")])])]),_("p",[a._v("业务发送者   -    p1 - 3m     -    消费组2     - 到期转发 - biz_topic - 业务消费者\n-    p2 - 10m   -      消费组3")]),a._v(" "),_("ul",[_("li",[a._v("delay_topic 里面的分区被用来接收不同延迟时间的消息。比如说在上图中分成了 p0、p1、p2 三个分区，分别用于接收延迟时间为 1min、3min和10min的消息。")]),a._v(" "),_("li",[a._v("延迟消费组会创建出和分区数量一样的消费者，每一个消费者消费一个分区。消费者每次读取一个消息，等延迟足够长的时间之后，就会转发给biz_topic。")])]),a._v(" "),_("p",[a._v("对于业务发送者，根据自己的延迟时间来选择正确的分区。消费者对这个过程是无感的。")]),a._v(" "),_("blockquote",[_("p",[a._v("我们可以创建一个delay_topic，它有n个分区可以设定了不同的延迟时间。然后创建一个消费组去消费这个delay_logic，每个分区有一个独立的消费者。\n每个消费者读到这条消息之后，根据消息里的延迟时间来等待一段时间。\n等待完成之后，再把消息发送到业务方真正的topic上。")])]),a._v(" "),_("p",[a._v("n可以很灵活：")]),a._v(" "),_("ul",[_("li",[a._v("5个分区：延迟时间分别是 1min、3min、5min、10min、30min。")]),a._v(" "),_("li",[a._v("10个分区：延迟时间分别是 1min、3min，5min、10min、15min、30min、60min、90min、120min、180min。")])]),a._v(" "),_("h4",{attrs:{id:"rebalance"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rebalance"}},[a._v("#")]),a._v(" rebalance")]),a._v(" "),_("p",[a._v("在该方案中，因为消费者睡眠了，睡眠期间不会消费消息，所以kafka就会判定这个消费者已经崩溃了，就会触发rebalance。")])])}),[],!1,null,null,null);_.default=e.exports}}]);
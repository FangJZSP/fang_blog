<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面经｜技术栈问答 | 放|FangJZSP</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="头像.jpg">
    <meta name="description" content="放，就这水平！！！">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/fang_blog/assets/css/0.styles.72d2c4fb.css" as="style"><link rel="preload" href="/fang_blog/assets/js/app.8dbc3baf.js" as="script"><link rel="preload" href="/fang_blog/assets/js/3.d5c9c33c.js" as="script"><link rel="preload" href="/fang_blog/assets/js/1.3f023f4a.js" as="script"><link rel="preload" href="/fang_blog/assets/js/56.92051efa.js" as="script"><link rel="prefetch" href="/fang_blog/assets/js/10.f0d76add.js"><link rel="prefetch" href="/fang_blog/assets/js/100.28282fe8.js"><link rel="prefetch" href="/fang_blog/assets/js/101.0a268033.js"><link rel="prefetch" href="/fang_blog/assets/js/102.323534cc.js"><link rel="prefetch" href="/fang_blog/assets/js/103.c0b41ce3.js"><link rel="prefetch" href="/fang_blog/assets/js/104.e449ff57.js"><link rel="prefetch" href="/fang_blog/assets/js/105.6a92b89a.js"><link rel="prefetch" href="/fang_blog/assets/js/106.980d44bf.js"><link rel="prefetch" href="/fang_blog/assets/js/107.ea0a7f8f.js"><link rel="prefetch" href="/fang_blog/assets/js/108.f30ca041.js"><link rel="prefetch" href="/fang_blog/assets/js/109.42415fa8.js"><link rel="prefetch" href="/fang_blog/assets/js/11.9cdb737f.js"><link rel="prefetch" href="/fang_blog/assets/js/110.69e898c9.js"><link rel="prefetch" href="/fang_blog/assets/js/111.2b6a92e0.js"><link rel="prefetch" href="/fang_blog/assets/js/112.3b443edd.js"><link rel="prefetch" href="/fang_blog/assets/js/113.170bb85f.js"><link rel="prefetch" href="/fang_blog/assets/js/114.ce720583.js"><link rel="prefetch" href="/fang_blog/assets/js/115.51550ce8.js"><link rel="prefetch" href="/fang_blog/assets/js/116.86c61c12.js"><link rel="prefetch" href="/fang_blog/assets/js/117.cd36d235.js"><link rel="prefetch" href="/fang_blog/assets/js/118.d2aa2818.js"><link rel="prefetch" href="/fang_blog/assets/js/119.dfc85732.js"><link rel="prefetch" href="/fang_blog/assets/js/12.c390a872.js"><link rel="prefetch" href="/fang_blog/assets/js/120.acc89b77.js"><link rel="prefetch" href="/fang_blog/assets/js/121.a2ca8c7b.js"><link rel="prefetch" href="/fang_blog/assets/js/122.34558db5.js"><link rel="prefetch" href="/fang_blog/assets/js/13.db6805ad.js"><link rel="prefetch" href="/fang_blog/assets/js/14.3ca931fc.js"><link rel="prefetch" href="/fang_blog/assets/js/15.bc9b8122.js"><link rel="prefetch" href="/fang_blog/assets/js/16.bbc72478.js"><link rel="prefetch" href="/fang_blog/assets/js/17.6aa92457.js"><link rel="prefetch" href="/fang_blog/assets/js/18.3b8c3544.js"><link rel="prefetch" href="/fang_blog/assets/js/19.3720bd61.js"><link rel="prefetch" href="/fang_blog/assets/js/20.3427a82e.js"><link rel="prefetch" href="/fang_blog/assets/js/21.0e0d11a1.js"><link rel="prefetch" href="/fang_blog/assets/js/22.4e83b8c9.js"><link rel="prefetch" href="/fang_blog/assets/js/23.4898c543.js"><link rel="prefetch" href="/fang_blog/assets/js/24.fa4424d2.js"><link rel="prefetch" href="/fang_blog/assets/js/25.a376524e.js"><link rel="prefetch" href="/fang_blog/assets/js/26.a31ca862.js"><link rel="prefetch" href="/fang_blog/assets/js/27.438348b8.js"><link rel="prefetch" href="/fang_blog/assets/js/28.91241cb6.js"><link rel="prefetch" href="/fang_blog/assets/js/29.58c07c4b.js"><link rel="prefetch" href="/fang_blog/assets/js/30.dc74b7f9.js"><link rel="prefetch" href="/fang_blog/assets/js/31.c4e67281.js"><link rel="prefetch" href="/fang_blog/assets/js/32.94559ffa.js"><link rel="prefetch" href="/fang_blog/assets/js/33.1edfe33f.js"><link rel="prefetch" href="/fang_blog/assets/js/34.bb7140a4.js"><link rel="prefetch" href="/fang_blog/assets/js/35.156904ee.js"><link rel="prefetch" href="/fang_blog/assets/js/36.0d2875d2.js"><link rel="prefetch" href="/fang_blog/assets/js/37.0119dcaa.js"><link rel="prefetch" href="/fang_blog/assets/js/38.ff81aade.js"><link rel="prefetch" href="/fang_blog/assets/js/39.95056f0b.js"><link rel="prefetch" href="/fang_blog/assets/js/4.5b40ea71.js"><link rel="prefetch" href="/fang_blog/assets/js/40.c5b78318.js"><link rel="prefetch" href="/fang_blog/assets/js/41.c4b55c58.js"><link rel="prefetch" href="/fang_blog/assets/js/42.f1e526c3.js"><link rel="prefetch" href="/fang_blog/assets/js/43.2da5ad5c.js"><link rel="prefetch" href="/fang_blog/assets/js/44.bcb10cbd.js"><link rel="prefetch" href="/fang_blog/assets/js/45.143c9d01.js"><link rel="prefetch" href="/fang_blog/assets/js/46.d57d89d5.js"><link rel="prefetch" href="/fang_blog/assets/js/47.b1a9d230.js"><link rel="prefetch" href="/fang_blog/assets/js/48.7cf175e1.js"><link rel="prefetch" href="/fang_blog/assets/js/49.d4b80112.js"><link rel="prefetch" href="/fang_blog/assets/js/5.e585f060.js"><link rel="prefetch" href="/fang_blog/assets/js/50.b294f1d7.js"><link rel="prefetch" href="/fang_blog/assets/js/51.92e6630a.js"><link rel="prefetch" href="/fang_blog/assets/js/52.bd1de398.js"><link rel="prefetch" href="/fang_blog/assets/js/53.4a698f74.js"><link rel="prefetch" href="/fang_blog/assets/js/54.6eed3b34.js"><link rel="prefetch" href="/fang_blog/assets/js/55.a510c147.js"><link rel="prefetch" href="/fang_blog/assets/js/57.5ac2c3d8.js"><link rel="prefetch" href="/fang_blog/assets/js/58.b6b26eea.js"><link rel="prefetch" href="/fang_blog/assets/js/59.2d076bd8.js"><link rel="prefetch" href="/fang_blog/assets/js/6.731d207f.js"><link rel="prefetch" href="/fang_blog/assets/js/60.60804a5c.js"><link rel="prefetch" href="/fang_blog/assets/js/61.53ce21a1.js"><link rel="prefetch" href="/fang_blog/assets/js/62.16b18327.js"><link rel="prefetch" href="/fang_blog/assets/js/63.dd3f2e4d.js"><link rel="prefetch" href="/fang_blog/assets/js/64.a54ca66b.js"><link rel="prefetch" href="/fang_blog/assets/js/65.43e4c403.js"><link rel="prefetch" href="/fang_blog/assets/js/66.d2cc48c3.js"><link rel="prefetch" href="/fang_blog/assets/js/67.6dd9b8c9.js"><link rel="prefetch" href="/fang_blog/assets/js/68.c8ab3914.js"><link rel="prefetch" href="/fang_blog/assets/js/69.de6d733c.js"><link rel="prefetch" href="/fang_blog/assets/js/7.5a5b2d02.js"><link rel="prefetch" href="/fang_blog/assets/js/70.3f054ec7.js"><link rel="prefetch" href="/fang_blog/assets/js/71.cbf1c46f.js"><link rel="prefetch" href="/fang_blog/assets/js/72.695ebf98.js"><link rel="prefetch" href="/fang_blog/assets/js/73.a5889b43.js"><link rel="prefetch" href="/fang_blog/assets/js/74.3c210ea9.js"><link rel="prefetch" href="/fang_blog/assets/js/75.129b0790.js"><link rel="prefetch" href="/fang_blog/assets/js/76.45947065.js"><link rel="prefetch" href="/fang_blog/assets/js/77.12b75051.js"><link rel="prefetch" href="/fang_blog/assets/js/78.ec7c9b44.js"><link rel="prefetch" href="/fang_blog/assets/js/79.902cdaa3.js"><link rel="prefetch" href="/fang_blog/assets/js/8.4ed44d5b.js"><link rel="prefetch" href="/fang_blog/assets/js/80.842e525e.js"><link rel="prefetch" href="/fang_blog/assets/js/81.58ac443a.js"><link rel="prefetch" href="/fang_blog/assets/js/82.e0059c58.js"><link rel="prefetch" href="/fang_blog/assets/js/83.1abd0867.js"><link rel="prefetch" href="/fang_blog/assets/js/84.d7185511.js"><link rel="prefetch" href="/fang_blog/assets/js/85.16a92580.js"><link rel="prefetch" href="/fang_blog/assets/js/86.2e57a1f8.js"><link rel="prefetch" href="/fang_blog/assets/js/87.ccca66f8.js"><link rel="prefetch" href="/fang_blog/assets/js/88.abd24c06.js"><link rel="prefetch" href="/fang_blog/assets/js/89.7cfff85d.js"><link rel="prefetch" href="/fang_blog/assets/js/9.3437b5cf.js"><link rel="prefetch" href="/fang_blog/assets/js/90.3847167d.js"><link rel="prefetch" href="/fang_blog/assets/js/91.a6ed2f01.js"><link rel="prefetch" href="/fang_blog/assets/js/92.010d2d2a.js"><link rel="prefetch" href="/fang_blog/assets/js/93.3df292bd.js"><link rel="prefetch" href="/fang_blog/assets/js/94.1dbfc8cd.js"><link rel="prefetch" href="/fang_blog/assets/js/95.94077f67.js"><link rel="prefetch" href="/fang_blog/assets/js/96.db9537fd.js"><link rel="prefetch" href="/fang_blog/assets/js/97.8128b970.js"><link rel="prefetch" href="/fang_blog/assets/js/98.b30e0be2.js"><link rel="prefetch" href="/fang_blog/assets/js/99.629a49a1.js">
    <link rel="stylesheet" href="/fang_blog/assets/css/0.styles.72d2c4fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>放|FangJZSP</h3> <p class="description" data-v-59e6cb88>放，就这水平！！！</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Fang</span>
          
        <span data-v-59e6cb88>2024 - </span>
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fang_blog/" class="home-link router-link-active"><img src="/fang_blog/头像.jpg" alt="放|FangJZSP" class="logo"> <span class="site-name">放|FangJZSP</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fang_blog/" class="nav-link"><i class="iconfont reco-home"></i>
  随便看看的主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      缝缝补补的文章
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fang_blog/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/服务器/" class="nav-link"><i class="undefined"></i>
  服务器
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/移动端/" class="nav-link"><i class="undefined"></i>
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/编程思想/" class="nav-link"><i class="undefined"></i>
  编程思想
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/随想/" class="nav-link"><i class="undefined"></i>
  随想
</a></li></ul></div></div><div class="nav-item"><a href="/fang_blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  无关紧要的小标签
</a></div><div class="nav-item"><a href="/fang_blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  不知所措的时间线
</a></div><div class="nav-item"><a href="http://chat.relaxing.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-chat"></i>
  摸鱼聊天室
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系我吧~
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangJZSP" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/fang_blog/头像.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    Fang
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>112</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>27</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/fang_blog/" class="nav-link"><i class="iconfont reco-home"></i>
  随便看看的主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      缝缝补补的文章
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fang_blog/categories/后端/" class="nav-link"><i class="undefined"></i>
  后端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/服务器/" class="nav-link"><i class="undefined"></i>
  服务器
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/移动端/" class="nav-link"><i class="undefined"></i>
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/编程思想/" class="nav-link"><i class="undefined"></i>
  编程思想
</a></li><li class="dropdown-item"><!----> <a href="/fang_blog/categories/随想/" class="nav-link"><i class="undefined"></i>
  随想
</a></li></ul></div></div><div class="nav-item"><a href="/fang_blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  无关紧要的小标签
</a></div><div class="nav-item"><a href="/fang_blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  不知所措的时间线
</a></div><div class="nav-item"><a href="http://chat.relaxing.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-chat"></i>
  摸鱼聊天室
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系我吧~
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/FangJZSP" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>面经｜技术栈问答</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Fang</span>
          
        <span data-v-59e6cb88>2024 - </span>
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">面经｜技术栈问答</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>Fang</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/5/23</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>后端</span><span class="tag-item" data-v-8a445198>Java</span></i></div></div> <div class="theme-reco-content content__default"><h3 id="掌握技术"><a href="#掌握技术" class="header-anchor">#</a> 掌握技术</h3> <hr> <ul><li>熟练使用<strong>Javase</strong>，掌握集合、多线程、并发等概念，具有良好的编码习惯和面向对象思想。</li> <li>熟练使用<strong>Spring</strong>，<strong>SpringMVC</strong>，<strong>Mybaits</strong>，<strong>MybatisPlus</strong>等主流开发框架。</li> <li>熟练使用<strong>MySQL</strong>，了解索引、事务实现机制，可以根据需求进行SQL优化。</li> <li>熟练使用非关系型数据库<strong>Redis</strong>，使用Redis缓存技术对项目进行优化，了解缓存雪崩，缓存穿透，缓存击穿的解决方案，了解Redisson分布式锁的实现原理。</li> <li>了解<strong>SpringCloud</strong>微服务框架，如：Nacos、GateWay、Fegin、Ribbon、Sentinel。</li> <li>了解<strong>linux</strong>命令，使用镜像CentOS7搭建虚拟机，掌握Finalshell远程服务连接工具。</li> <li>了解<strong>Docker</strong>基本使用和命令，部署常用软件。</li> <li>了解<strong>Nginx</strong>服务器， 能够搭建基于Nginx负载均衡，反向代理。</li> <li>了解<strong>ElasticSearch</strong>全文检索技术，<strong>RibbitMQ</strong>消息中间件，了解其使用场景。</li> <li>了解<strong>HTML</strong>，<strong>CSS</strong>，<strong>JS</strong>，<strong>AJAX</strong>，<strong>VUE</strong>和<strong>Element-ui</strong>的常规使用。</li> <li>掌握<strong>IDEA</strong>，<strong>VSCode</strong>，<strong>Maven</strong>，<strong>NaviCat</strong>，<strong>PostMan</strong>，<strong>Git</strong>等开发常用工具。</li></ul> <h3 id="javase"><a href="#javase" class="header-anchor">#</a> Javase</h3> <h4 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h4> <h5 id="泛谈"><a href="#泛谈" class="header-anchor">#</a> 泛谈</h5> <h6 id="面-说说你对集合的了解吧"><a href="#面-说说你对集合的了解吧" class="header-anchor">#</a> 面：说说你对集合的了解吧</h6> <p>我：面试官你好，我简单说一下我对集合框架的理解。集合它分为两种，一种是单列集合connection，一种是双列集合map。</p> <p>那么connection它有两个子接口，一个是list，还有这个set。list是有序可重复的，set是无序且唯一的。</p> <p>对于list它也有三个子接口，第一个子接口是vector，它是数组结构，它也是这个线程安全的，我们这里线程安全一般说的是它的方法上有这个synchronize这个锁的。那么ArrayList呢，它也是数组结构，是非线程安全的。还有这个linkedlist它是个双向链表结构，非线程安全的。</p> <p>对于set呢，它有两个子接口，第一个是hashset，hash表结构，它是基于hash算法的一种结构，它还有一个实现类，就是linkedhash
set，它是哈希表和链表的一种结构。第二个子接口set就是treeset，它是红黑数结构。</p> <p>对于双列集合map来说，它有四种实现类，第一个是hashtable，hash表结构，线程安全的。那么但是hashtable，它现在已经很少用了，因为它的这个性能比较差，它的一个子接口properties还会做配置文件存储。第二个是hashmap，它是一种哈希表结构，是非线程安全的，它有一个实现类，也是这个linkdhashmap，它是哈希表和链表结构。第三个比较常用的有这个concurrenthashmap，它是哈希表结构，线程安全。另外最后一种的就是treemap，红黑树结构。</p> <h5 id="挖深"><a href="#挖深" class="header-anchor">#</a> 挖深</h5> <h6 id="面-深讲一下arraylist"><a href="#面-深讲一下arraylist" class="header-anchor">#</a> 面：深讲一下arraylist</h6> <ul><li><p>arraylist中维护了一个object类型的数组，elementdata transient object[] elementdata; transient 表示瞬间，短暂的，表示该属性不会被序列化</p></li> <li><p>允许所有元素加入，arraylist可以加入null 并且多个</p></li> <li><p>ArrayList基本等同于vector，除了arraylist是线程不安全（执行效率高），在多线程情况下，不建议使用ArrayList</p></li> <li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementdata容量为0，第一次添加，则扩容elementData 为
10，如需要再次扩容，则扩容elementdata为1.5倍</p></li> <li><p>如果使用的是指定大小的构造器，则初始elementdata容量为指定大小，如果需要扩容，则直接扩容为1.5倍</p></li> <li></li></ul> <p>添加逻辑：确保数组已使用长度（size）加1之后足够存下下一个数据计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。返回添加成功布尔值。</p> <h6 id="面-深讲一下linkedlist"><a href="#面-深讲一下linkedlist" class="header-anchor">#</a> 面：深讲一下linkedlist</h6> <ul><li><p>linkedlist底层实现了双向链表和双端队列的特点</p></li> <li><p>可以添加任意元素，元素可以重复，包括null</p></li> <li><p>线程不安全，没有实现同步</p></li> <li><p>ps：&quot;线程不安全&quot;指的是LinkedList在多线程环境下可能会出现竞争和冲突的情况，导致数据错误或程序崩溃等问题。而&quot;没有实现同步&quot;
则表示LinkedList类没有加入对线程同步的相关处理，即没有采取措施来避免这些潜在的线程问题。</p></li></ul> <h6 id="面-arraylist和linkedlist区别"><a href="#面-arraylist和linkedlist区别" class="header-anchor">#</a> 面：arraylist和linkedlist区别</h6> <ul><li><p>ArrayList 可变数组 增删较低 数组扩容 改查效率较高</p></li> <li><p>linkedlist 双向链表 增删效率较高 改查效率较低</p></li></ul> <h6 id="面-数组和list如何互相转"><a href="#面-数组和list如何互相转" class="header-anchor">#</a> 面：数组和list如何互相转</h6> <p>要将数组转换为List，可以使用Arrays类中的asList()
方法。该方法将数组转换为List，并返回List的视图，除了添加和删除操作以外，其他操作都可以使用。Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要将List转换为数组，可以使用List的toArray()
方法。该方法将List转换为数组，并且可以指定数组的类型。llist用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果数组是基本数据类型，例如int、float等，可以使用Apache Commons Lang库中的ArrayUtils类，它提供了一些实用的方法来转换数组。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">ArrayUtils</span><span class="token punctuation">.</span><span class="token function">toObject</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> <span class="token class-name">ArrayUtils</span><span class="token punctuation">.</span><span class="token function">toPrimitive</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="面-深讲一下hashmap"><a href="#面-深讲一下hashmap" class="header-anchor">#</a> 面：深讲一下hashmap</h6> <ul><li><p>hashmap是map接口使用频率最高的实现类</p></li> <li><p>hashmap是以key-value对的方式来存储数据（hashmao$node类型）</p></li> <li><p>key不能重复，但是值可以重读，允许使用null键和null值</p></li> <li><p>如果添加相同的key，则会覆盖原来的key-val，等同于修改</p></li> <li><p>与hashset一样，不保证映射的顺序，因为底层是以hash表的方式来存储的 jdk8 的 hashmap 底层 数组+链表+红黑树</p></li> <li><p>hashmap没有实现同步，因此线程是不安全的，方法没有做同步互斥的操作，没有synchronized</p></li> <li><p>（k，v）是一个node实现了map.entry&lt;K,V&gt;,查看hashmap的源码可以看到</p></li> <li><p>jdk7的hashmap底层实现 数组+链表 jdk 8.0 底层 数组链表红黑树</p></li> <li><p>hashmap底层维护了node类型的数组table，默认为null</p></li> <li><p>当创建对象是，将加载因子loadfactor 初始化为0.75</p></li> <li></li></ul> <p>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换value；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容</p> <ul><li><p>第一次添加，则需要扩容table容量为16，临界值threshold为12，以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</p></li> <li><p>在java8中，如果一条链表的元素个数超过了treeify threshold 默认为8 ，并且table的大小 &gt;=min treeify capacity 默认64，就会进行树化
红黑树</p></li></ul> <h4 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h4> <h5 id="线程基础"><a href="#线程基础" class="header-anchor">#</a> 线程基础</h5> <h6 id="面-线程和进程区别"><a href="#面-线程和进程区别" class="header-anchor">#</a> 面：线程和进程区别</h6> <p>线程就是一个指令流，指令流按顺序交给cpu执行</p> <p>进程是正在运行程序的实例，进程中有线程，每个线程执行不同的任务</p> <p>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</p> <p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</p> <p><strong>守护线程</strong></p> <p>守护线程是在后台运行的线程，它的任务是为其他线程提供服务和支持。当程序中仅剩下守护线程时，它会自动退出。</p> <p>在 Java 中，可以使用 setDaemon() 方法将线程设置为守护线程。当程序中所有非守护线程都退出时，JVM
会自动结束守护线程。因此，守护线程通常被用来执行一些不需要完全执行或可以被中途中断的任务。</p> <p>守护线程的特点包括：</p> <ul><li>它在运行时始终在后台运行，不会阻碍程序的退出。</li> <li>它没有独立的程序入口，需要依托于其他线程。</li> <li>它经常被用来执行一些后台任务，如垃圾回收、定时任务等。</li></ul> <p>需要注意的是，守护线程可能无法完成某些操作，因为它可能会在程序退出前被强制终止。因此，在运行守护线程时需要格外小心，确保它们的任务可以安全地中断和恢复。</p> <h6 id="面-并发和并行的区别"><a href="#面-并发和并行的区别" class="header-anchor">#</a> 面：并发和并行的区别</h6> <p>并发：微观串行，宏观并发，线程轮流使用CPU的做法称为并发，同一时间面对多件事情</p> <p>并行：多核心可以有多个线程运行</p> <h6 id="面-创建线程的方式有哪些"><a href="#面-创建线程的方式有哪些" class="header-anchor">#</a> 面：创建线程的方式有哪些</h6> <ul><li><p>继承Thread类 new对象 调用start方法</p></li> <li><p>实现runnable接口 new对象 调用start方法</p></li> <li><p>实现Callable接口 设置泛型 new对象 包装自己的对象 调用start方法</p></li> <li><p>线程池创建线程 继承runnable接口 创建线程池对象 关闭线程池（项目使用方式）</p></li></ul> <h6 id="面-runnable和callable实现区别"><a href="#面-runnable和callable实现区别" class="header-anchor">#</a> 面：runnable和Callable实现区别</h6> <ul><li><p>runnable没有返回值，callable有返回值，看看结果</p></li> <li><p>Runnable还有泛型定义，还可以获取返回值，能获得异常</p></li> <li><p>run不能向上抛异常，但可以trycatch，内部消化</p></li></ul> <h6 id="面-run和start的区别"><a href="#面-run和start的区别" class="header-anchor">#</a> 面：run和start的区别</h6> <p>run就是调用普通方法，随便调用</p> <p>start才是线程真正的开启，线程只能开启一次</p> <h6 id="面-线程有哪些状态-状态之间怎么变化"><a href="#面-线程有哪些状态-状态之间怎么变化" class="header-anchor">#</a> 面：线程有哪些状态，状态之间怎么变化</h6> <ul><li>参考jdk中thread类中的枚举state
<ul><li>new 没开启的线程 可以创建 就绪状态 有执行权start开始</li> <li>unnable 正在运行的 抢到cpu和锁</li> <li>blocker 被阻塞的 拿不到锁</li> <li>waiting 等待的 notify唤醒 wait你等吧</li> <li>time_waitting 等一段时间就开始执行的 sleep让你睡觉</li> <li>terminated 死亡的线程 不要你了</li></ul></li></ul> <h6 id="面-新建三个线程-如何让它们按顺序执行"><a href="#面-新建三个线程-如何让它们按顺序执行" class="header-anchor">#</a> 面：新建三个线程，如何让它们按顺序执行</h6> <ul><li>使用join方法 就是加入呗 trycatch 每次执行 让你线程执行完 我接着进行 这里使用了一下匿名内部类？还是lamaba表达式？</li></ul> <h6 id="面-notify和notifyall区别"><a href="#面-notify和notifyall区别" class="header-anchor">#</a> 面：notify和notifyall区别</h6> <p>一个唤醒随机一个</p> <p>一个唤醒所有线程</p> <h6 id="面-wait和sleep不同"><a href="#面-wait和sleep不同" class="header-anchor">#</a> 面：wait和sleep不同</h6> <p>相同点：都能让当前线程放弃spu使用权</p> <p>不同点：</p> <p>方法归属不同，sleep是thread的静态方法，wait是object成员方法，每个对象都有</p> <p>醒来时机不同，说不清清楚</p> <p>锁特性不同，wait必须获得对象锁，sleep不用，wait可以释放对象锁，允许其他线程用，但是sleep在synchronized代码块中执行，放弃了，其他线程也用不来</p> <h6 id="面-如何停止一个正在运行的线程"><a href="#面-如何停止一个正在运行的线程" class="header-anchor">#</a> 面：如何停止一个正在运行的线程</h6> <ul><li>使用退出标志 flag 更改状态就行</li> <li>使用stop方法强行终止，已经不用了</li> <li>使用interrupt方法
<ul><li>打断阻塞的线程，线程会抛出interruptedExceptation</li> <li>打断正常的线程，可以根据打断状态来标记是否退出线程</li></ul></li></ul> <h5 id="线程安全"><a href="#线程安全" class="header-anchor">#</a> 线程安全</h5> <h6 id="面-synchronized关键字的底层原理-基础"><a href="#面-synchronized关键字的底层原理-基础" class="header-anchor">#</a> 面：synchronized关键字的底层原理-基础</h6> <p>非原子性操作，需要一个对象锁，同一时刻只能一个人拿到这个锁，其他线程也会被阻塞</p> <p>monitor class反汇编</p> <ul><li>上锁 解锁 解锁</li></ul> <p>monitor是监视器，由jvm提供，c++语言实现</p> <ul><li>三个属性 waitset等待调用后等待的放这里 entrylis阻塞队列没有排队不是先来后到 owner只能关联一个线程</li></ul> <p>想到了操作系统 非公平锁 互斥</p> <h6 id="面-synchronized关键字的底层原理-进阶"><a href="#面-synchronized关键字的底层原理-进阶" class="header-anchor">#</a> 面：synchronized关键字的底层原理-进阶</h6> <p>问题抛出：moniter实现的锁属于重量级锁 锁升级</p> <ul><li>涉及到了用户态和核心态的切换、进程的上下文切换，成本较高，性能低</li> <li>jdk1.6引入了两种新锁机制，偏向锁和轻量级锁，引入是解决没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li></ul> <p><strong>对象内存结构 hotspot虚拟机 对象在内存中的布局分为3块区域 对象头 实例数据 对齐填充</strong></p> <p>对象头 对象头 描述对象实例的具体类型</p> <p>实例数据 成员变量</p> <p>对齐填充 如果是不会8的整数倍，则通过对齐填充补齐 这里就是要求地址 不散吧</p> <p><strong>Markword</strong></p> <table><thead><tr><th><strong>Mark Word (32 bits)</strong></th> <th></th> <th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>hashcode : 25</td> <td></td> <td>age : 4</td> <td>biased_lock : 0</td> <td>01</td> <td>无锁</td></tr> <tr><td>thread : 23</td> <td>epoch : 2</td> <td>age : 4</td> <td>biased_lock : 1</td> <td>01</td> <td>偏向锁</td></tr> <tr><td>ptr_to_lock_record : 30</td> <td></td> <td></td> <td></td> <td>00</td> <td>轻量级锁</td></tr> <tr><td>ptr_to_heavyweight_monitor : 30</td> <td></td> <td></td> <td></td> <td>10</td> <td>重量级锁</td></tr> <tr><td></td> <td></td> <td></td> <td></td> <td>11</td> <td>标记为GC</td></tr></tbody></table> <p>hashcode：25位的对象标识Hash码</p> <p>lock标识：2位</p> <p>age：对象分代年龄占4位</p> <p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p> <p>thread：持有偏向锁的线程ID，占23位</p> <p>epoch：偏向时间戳，占2位</p> <p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p> <p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p> <p><strong>轻量级锁</strong></p> <p>为什么用，竞争不激烈，用性能消耗更少的的轻量级锁。</p> <ul><li>加锁流程</li></ul> <p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p> <p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p> <p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p> <p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p> <ul><li>解锁过程</li></ul> <p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p> <p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p> <p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p> <p><strong>偏向锁</strong></p> <p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。为了性能更好，Java 6 中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程
ID设置到对象的MarkWord 头，之后发现这个线程ID是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p> <h6 id="面-mintor实现的锁属于重量级锁-锁升级了解吗"><a href="#面-mintor实现的锁属于重量级锁-锁升级了解吗" class="header-anchor">#</a> 面：Mintor实现的锁属于重量级锁，锁升级了解吗</h6> <p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p> <table><thead><tr><th style="text-align:left;"></th> <th><strong>描述</strong></th></tr></thead> <tbody><tr><td style="text-align:left;">重量级锁</td> <td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td></tr> <tr><td style="text-align:left;">轻量级锁</td> <td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td></tr> <tr><td style="text-align:left;">偏向锁</td> <td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td></tr></tbody></table> <p>一旦锁发生了竞争，都会升级为重量级锁。</p> <h6 id="面-谈谈jmm"><a href="#面-谈谈jmm" class="header-anchor">#</a> 面：谈谈JMM</h6> <p>Java Memory Model：定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</p> <p>简单来说就是java内存模型给内存读取写入定义的行为规范。</p> <h6 id="面-谈谈你对cas理解"><a href="#面-谈谈你对cas理解" class="header-anchor">#</a> 面：谈谈你对CAS理解</h6> <p>CAS是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p> <p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作，如：lAbstractQueuedSynchronizer（AQS框架），lAtomicXXX类</p> <p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功。</p> <p>优缺点：因为没有加锁，所以线程不会陷入阻塞，效率较高，如果竞争激烈，重试频繁发生，效率会受影响</p> <p>底层实现：CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p> <h6 id="面-乐观锁和悲观锁"><a href="#面-乐观锁和悲观锁" class="header-anchor">#</a> 面：乐观锁和悲观锁</h6> <ul><li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。像redis的版本号控制法，但是要高并发的情况下，很有可能出现东西卖不出去的可能</p></li> <li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li></ul> <h6 id="面-请谈谈对volatile的理解"><a href="#面-请谈谈对volatile的理解" class="header-anchor">#</a> 面：请谈谈对volatile的理解</h6> <p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p> <ul><li><p>保证线程间的可见性 用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p></li> <li><p>禁止进行指令重排序 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p></li></ul> <h6 id="面-什么是aqs"><a href="#面-什么是aqs" class="header-anchor">#</a> 面：什么是AQS</h6> <ul><li><p>是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的，像ReentrantLock、Semaphore、countDownLatch都是基于AQS实现的</p></li> <li><p>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</p></li> <li><p>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</p></li> <li><p>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</p></li></ul> <h6 id="面-reentrantlock的实现原理"><a href="#面-reentrantlock的实现原理" class="header-anchor">#</a> 面：ReentrantLock的实现原理</h6> <p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p> <ul><li>ReentrantLock表示支持重新进入的锁，调用lock方法获取了锁之后，再次调用 lock，是不会再阻塞</li> <li>ReentrantLock主要利用CAS+AQS队列来实现</li> <li>支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁</li></ul> <h6 id="面-synchronized和lock有什么区别"><a href="#面-synchronized和lock有什么区别" class="header-anchor">#</a> 面：synchronized和Lock有什么区别</h6> <ul><li>语法层面</li></ul> <p>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</p> <p>Lock 是接口，源码由 jdk 提供，用 java 语言实现</p> <p>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</p> <ul><li>功能层面</li></ul> <p>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</p> <p>Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量</p> <p>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)</p> <ul><li>性能层面</li></ul> <p>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</p> <p>在竞争激烈时，Lock 的实现通常会提供更好的性能，像redis确实会使用lock</p> <h6 id="面-死锁出现的条件"><a href="#面-死锁出现的条件" class="header-anchor">#</a> 面：死锁出现的条件</h6> <p>一个线程需要同时获取多把锁，这时就容易发生死锁</p> <p>怎么发现：</p> <ul><li><p>jps：输出JVM中运行的进程状态信息</p></li> <li><p>jstack：查看java进程内线程的堆栈信息</p></li></ul> <p>其他可视化工具也可以</p> <h6 id="面-聊一下concurrenthashmap"><a href="#面-聊一下concurrenthashmap" class="header-anchor">#</a> 面：聊一下concurrenthashmap</h6> <p>ConcurrentHashMap 是一种线程安全的高效Map集合</p> <p>底层数据结构：</p> <ul><li><p>JDK1.7底层采用分段的数组+链表实现</p></li> <li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树</p></li></ul> <p>加锁的方式</p> <ul><li><p>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</p></li> <li><p>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</p></li></ul> <h6 id="面-导致并发程序出现问题的根本原因是什么"><a href="#面-导致并发程序出现问题的根本原因是什么" class="header-anchor">#</a> 面：导致并发程序出现问题的根本原因是什么</h6> <ul><li><p>原子性 synchronized、lock</p></li> <li><p>内存可见性 volatile、synchronized、lock 让一个线程对共享变量的修改对另一个线程可见</p></li> <li><p>有序性 volatile 指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的，防止先读后写</p></li></ul> <h5 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h5> <h6 id="面-说一下线程池的核心参数-线程池的执行原理知道吗"><a href="#面-说一下线程池的核心参数-线程池的执行原理知道吗" class="header-anchor">#</a> 面：说一下线程池的核心参数，线程池的执行原理知道吗</h6> <ul><li><p>corePoolSize 核心线程数目</p></li> <li><p>maximumPoolSize 最大线程数目 = (核心线程+救急线程的最大数目)</p></li> <li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p></li> <li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p></li> <li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p></li> <li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p></li> <li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p></li></ul> <p><strong>执行原理</strong></p> <p>提交任务-核心线程-阻塞队列-线程是否大于最大线程数-创建非核心线程执行任务-拒绝策略</p> <p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p> <p>拒绝策略：</p> <p>1.AbortPolicy：直接抛出异常，默认策略；</p> <p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p> <p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p> <p>4.DiscardPolicy：直接丢弃任务；</p> <h6 id="面-线程池中有哪些常见的阻塞队列"><a href="#面-线程池中有哪些常见的阻塞队列" class="header-anchor">#</a> 面：线程池中有哪些常见的阻塞队列</h6> <p>workQueue：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p> <p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p> <p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p> <p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p> <p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p> <p>区别：</p> <table><thead><tr><th><strong>LinkedBlockingQueue</strong></th> <th><strong>ArrayBlockingQueue</strong></th></tr></thead> <tbody><tr><td>默认无界，支持有界</td> <td>强制有界</td></tr> <tr><td>底层是链表</td> <td>底层是数组</td></tr> <tr><td>是懒惰的，创建节点的时候添加数据</td> <td>提前初始化 Node  数组</td></tr> <tr><td>入队会生成新 Node</td> <td>Node需要是提前创建好的</td></tr> <tr><td>两把锁（头尾）</td> <td>一把锁</td></tr></tbody></table> <h6 id="面-如何确定核心线程数"><a href="#面-如何确定核心线程数" class="header-anchor">#</a> 面：如何确定核心线程数</h6> <p>IO密集型任务：文件读写、DB读写、网络请求 2n+1</p> <p>CPU密集型任务：计算型、Bitmap转换、Gson转换 n+1</p> <p><strong>参考回答</strong></p> <p>参考回答：</p> <p>1、高并发、任务执行时间短（ CPU核数+1 ），减少线程上下文的切换</p> <p>2、并发不高、任务执行时间长</p> <ul><li><p>IO密集型的任务 (CPU核数 * 2 + 1)</p></li> <li><p>计算密集型任务（ CPU核数+1 ）</p></li></ul> <p>3、并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考2</p> <h6 id="面-线程池的种类"><a href="#面-线程池的种类" class="header-anchor">#</a> 面：线程池的种类</h6> <p>四种</p> <ul><li><p>newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</p></li> <li><p>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p></li> <li><p>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p></li> <li><p>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</p></li></ul> <h6 id="面-为什么不建议用executors创建线程池"><a href="#面-为什么不建议用executors创建线程池" class="header-anchor">#</a> 面：为什么不建议用Executors创建线程池</h6> <p>[强制]线程池不允许使用Executors去创建,而是通过ThreadPoolExecutor的方式,这样的处理方式让写的人更加明确线程池的运行规则,规避资源耗尽的风险。</p> <p>说明: Executors返回的线程池对象的弊端如下:</p> <ul><li><p>FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_ VALUE ,可能会堆积大量的请求,从而导致00M。</p></li> <li><p>CachedThreadPool：允许的创建线程数量为Integer.MAX_ VALUE ,可能会创建大量的线程,从而导致0OM。</p></li></ul> <h5 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h5> <h6 id="面-线程池使用场景-countdownlatch、future-你们项目哪里用到了多线程"><a href="#面-线程池使用场景-countdownlatch、future-你们项目哪里用到了多线程" class="header-anchor">#</a> 面：线程池使用场景（CountDownLatch、Future）你们项目哪里用到了多线程</h6> <p>CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）</p> <ul><li><p>其中构造参数用来初始化等待计数值</p></li> <li><p>await() 用来等待计数归零</p></li> <li><p>countDown() 用来让计数减一</p></li></ul> <p><strong>场景1</strong>：es数据批量导入</p> <p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出。</p> <p><strong>场景2</strong>：数据汇总</p> <p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p> <p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p> <p><strong>场景3</strong>：异步调用</p> <p>异步保存，常用于搜索？</p> <p><strong>总结</strong></p> <ul><li><p>批量导入：使用了线程池+CountDownLatch批量把数据库中的数据导入到了ES(任意)中，避免OOM</p></li> <li><p>数据汇总：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p></li> <li><p>异步线程（线程池）：为了避免下一级方法影响上一级方法（性能考虑），可使用异步线程调用下一个方法（不需要下一级方法返回值），可以提升方法响应时间</p></li></ul> <h6 id="面-如何控制某个方法允许并发访问线程的数量"><a href="#面-如何控制某个方法允许并发访问线程的数量" class="header-anchor">#</a> 面：如何控制某个方法允许并发访问线程的数量</h6> <p>Semaphore信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量。</p> <p>使用场景：</p> <p>通常用于那些资源有明确访问数量限制的场景，常用于限流 。</p> <p>Semaphore使用步骤</p> <ul><li><p>创建Semaphore对象，可以给一个容量</p></li> <li><p>semaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p></li> <li><p>semaphore.release()：释放一个信号量，此时信号量个数+1</p></li></ul> <h6 id="面-谈谈你对threadlocal的理解"><a href="#面-谈谈你对threadlocal的理解" class="header-anchor">#</a> 面：谈谈你对ThreadLocal的理解</h6> <p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal
同时实现了线程内的资源共享。</p> <p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection
上进行数据库的操作，避免A线程关闭了B线程的连接。</p> <p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离。</p> <h6 id="面-threadlocal内存泄露问题"><a href="#面-threadlocal内存泄露问题" class="header-anchor">#</a> 面：threadlocal内存泄露问题</h6> <p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p> <ul><li><p>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收
<em>Out of Memory：指内存不足错误，指某个程序或系统无法分配足够的内存，导致程序崩溃或系统不稳定。</em></p></li> <li><p>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</p></li></ul> <h6 id="面-总结一下threadlocal"><a href="#面-总结一下threadlocal" class="header-anchor">#</a> 面：总结一下ThreadLocal</h6> <p>1、ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</p> <p>2、ThreadLocal 同时实现了线程内的资源共享</p> <p>3、每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p> <p>a)调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线</p> <p>程的 ThreadLocalMap 集合中</p> <p>b)调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p> <p>c)调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p> <p>4、ThreadLocal内存泄漏问题</p> <p>ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 的内存并不会释放。建议主动 remove 释放
key，value。</p> <h3 id="框架"><a href="#框架" class="header-anchor">#</a> 框架</h3> <h4 id="spring"><a href="#spring" class="header-anchor">#</a> spring</h4> <h6 id="面-spring框架中的单例bean是线程安全的吗"><a href="#面-spring框架中的单例bean是线程安全的吗" class="header-anchor">#</a> 面：spring框架中的单例bean是线程安全的吗</h6> <p>spring框架中有@Scope注解，可以进行设置是否是单例。</p> <p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</p> <h6 id="面-什么是aop-你们项目中有没有使用到aop"><a href="#面-什么是aop-你们项目中有没有使用到aop" class="header-anchor">#</a> 面：什么是AOP，你们项目中有没有使用到AOP</h6> <p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p> <p>常见的AOP使用场景：</p> <ul><li><p>记录操作日志</p></li> <li><p>缓存处理</p></li> <li><p>Spring中内置的事务处理</p></li></ul> <h6 id="面-spring中的事务是如何实现的"><a href="#面-spring中的事务是如何实现的" class="header-anchor">#</a> 面：Spring中的事务是如何实现的</h6> <p>Spring支持编程式事务管理和声明式事务管理两种方式。</p> <ul><li><p>编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</p></li> <li><p>声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></li></ul> <h6 id="面-spring事务失效的情况"><a href="#面-spring事务失效的情况" class="header-anchor">#</a> 面：spring事务失效的情况</h6> <ul><li><p>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出</p></li> <li><p>抛出检查异常，配置rollbackFor属性为Exception</p></li> <li><p>非public方法导致的事务失效，改为public</p></li></ul> <h6 id="面-spring中bean的生命周期"><a href="#面-spring中bean的生命周期" class="header-anchor">#</a> 面：spring中bean的生命周期</h6> <p>1、通过BeanDefinition获取bean的定义信息</p> <p>2、调用构造函数实例化bean</p> <p>3、bean的依赖注入</p> <p>4、处理Aware接口(BeanNameAware、BeanFactoryAware、ApplicationContextAware)</p> <p>5、Bean的后置处理器BeanPostProcessor-前置</p> <p>6、初始化方法(InitializingBean、init-method)</p> <p>7、Bean的后置处理器BeanPostProcessor-后置</p> <p>8、销毁bean</p> <h6 id="面-spring的循环引用"><a href="#面-spring的循环引用" class="header-anchor">#</a> 面：spring的循环引用</h6> <p>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</p> <p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p> <p>1、一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p> <p>2、二级缓存：缓存早期的bean对象（生命周期还没走完）</p> <p>3、三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p> <h6 id="面-构造方法出现了循环依赖怎么解决"><a href="#面-构造方法出现了循环依赖怎么解决" class="header-anchor">#</a> 面：构造方法出现了循环依赖怎么解决</h6> <p>A依赖于B，B依赖于A，注入的方式是构造函数</p> <p><strong>原因</strong>：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入</p> <p><strong>解决方案</strong>：使用@Lazy进行懒加载，什么时候需要对象再进行bean对象的创建</p> <h6 id="面-spring常用注解"><a href="#面-spring常用注解" class="header-anchor">#</a> 面：spring常用注解</h6> <table><thead><tr><th><strong>注解</strong></th> <th><strong>说明</strong></th></tr></thead> <tbody><tr><td>@Component、@Controller、@Service、@Repository</td> <td>使用在类上用于实例化Bean</td></tr> <tr><td>@Autowired</td> <td>使用在字段上用于根据类型依赖注入</td></tr> <tr><td>@Qualifier</td> <td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr> <tr><td>@Scope</td> <td>标注Bean的作用范围</td></tr> <tr><td>@Configuration</td> <td>指定当前类是一个 Spring  配置类，当创建容器时会从该类上加载注解</td></tr> <tr><td>@ComponentScan</td> <td>用于指定 Spring  在初始化容器时要扫描的包</td></tr> <tr><td>@Bean</td> <td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr> <tr><td>@Import</td> <td>使用@Import导入的类会被Spring加载到IOC容器中</td></tr> <tr><td>@Aspect、@Before、@After、@Around、@Pointcut</td> <td>用于切面编程（AOP）</td></tr></tbody></table> <h4 id="springmvc"><a href="#springmvc" class="header-anchor">#</a> springmvc</h4> <h6 id="面-springmvc的执行流程"><a href="#面-springmvc的执行流程" class="header-anchor">#</a> 面：SpringMVC的执行流程</h6> <ul><li>视图阶段（老旧JSP等）</li></ul> <ol><li><p>用户通过浏览器发起HttpRequest请求到前端控制器 (DispatcherServlet)。</p></li> <li><p>DispatcherServlet 将用户请求发送给处理器映射器 (HandlerMapping)。</p></li> <li><p>处理器映射器 (HandlerMapping)会根据请求，找到负责处理该请求的处理器，并将其封装为处理器执行链返回 (
HandlerExecutionChain) 给 DispatcherServlet</p></li> <li><p>DispatcherServlet 会根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器(HandlerAdaptor)    --注，处理器适配器有多个</p></li> <li><p>处理器适配器 (HandlerAdaptoer) 会调用对应的具体的 Controller</p></li> <li><p>Controller 将处理结果及要跳转的视图封装到一个对象 ModelAndView 中并将其返回给处理器适配器 (HandlerAdaptor)</p></li> <li><p>HandlerAdaptor 直接将 ModelAndView 交给 DispatcherServlet ，至此，业务处理完毕</p></li> <li><p>业务处理完毕后，我们需要将处理结果展示给用户。于是DisptcherServlet调用ViewResolver，将ModelAndView中的视图名称封装为视图对象</p></li> <li><p>ViewResolver 将封装好的视图 (View) 对象返回给 DIspatcherServlet</p></li> <li><p>DispatcherServlet 调用视图对象，让其自己 (View) 进行渲染（将模型数据填充至视图中），形成响应对象 (HttpResponse)</p></li> <li><p>前端控制器 (DispatcherServlet) 响应 (HttpResponse) 给浏览器，展示在页面上。</p></li></ol> <ul><li>前后端分离阶段（接口开发，异步）</li></ul> <p>①用户发送出请求到前端控制器DispatcherServlet</p> <p>②DispatcherServlet收到请求调用HandlerMapping（处理器映射器）</p> <p>③HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p> <p>④DispatcherServlet调用HandlerAdapter（处理器适配器）</p> <p>⑤HandlerAdapter经过适配调用具体的处理器（Handler/Controller）</p> <p>⑥方法上添加了@ResponseBody</p> <p>⑦通过HttpMessageConverter来返回结果转换为JSON并响应</p> <h6 id="面-springmvc常用注解"><a href="#面-springmvc常用注解" class="header-anchor">#</a> 面：springmvc常用注解</h6> <table><thead><tr><th><strong>注解</strong></th> <th><strong>说明</strong></th></tr></thead> <tbody><tr><td>@RequestMapping</td> <td>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</td></tr> <tr><td>@RequestBody</td> <td>注解实现接收http请求的json数据，将json转换为java对象</td></tr> <tr><td>@RequestParam</td> <td>指定请求参数的名称</td></tr> <tr><td>@PathViriable</td> <td>从请求路径下中获取请求参数(/user/{id})，传递给方法的形式参数</td></tr> <tr><td>@ResponseBody</td> <td>注解实现将controller方法返回对象转化为json对象响应给客户端</td></tr> <tr><td>@RequestHeader</td> <td>获取指定的请求头数据</td></tr> <tr><td>@RestController</td> <td>@Controller  + @ResponseBody</td></tr></tbody></table> <h4 id="springboot"><a href="#springboot" class="header-anchor">#</a> springboot</h4> <h6 id="面-自动配置原理"><a href="#面-自动配置原理" class="header-anchor">#</a> 面：自动配置原理</h6> <p>1、在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p> <ul><li><p>@SpringBootConfiguration</p></li> <li><p>@EnableAutoConfiguration</p></li> <li><p>@ComponentScan</p></li></ul> <p>2、 其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入对应的配置选择器。</p> <p>内部就是读取了该项目和该项目引用的Jar包的的classpath路径下META-INF/spring.factories文件中的所配置的类的全类名。
在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中。</p> <p>3,、条件判断会有像@ConditionalOnClass这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p> <h6 id="面-springboot常用注解"><a href="#面-springboot常用注解" class="header-anchor">#</a> 面：springboot常用注解</h6> <table><thead><tr><th><strong>注解</strong></th> <th><strong>说明</strong></th></tr></thead> <tbody><tr><td>@SpringBootConfiguration</td> <td>组合了-  @Configuration注解，实现配置文件的功能</td></tr> <tr><td>@EnableAutoConfiguration</td> <td>打开自动配置的功能，也可以关闭某个自动配置的选</td></tr> <tr><td>@ComponentScan</td> <td>Spring组件扫描</td></tr></tbody></table> <h4 id="mybaits"><a href="#mybaits" class="header-anchor">#</a> mybaits</h4> <h6 id="面-执行流程"><a href="#面-执行流程" class="header-anchor">#</a> 面：执行流程</h6> <p>计算机的基本工作就是存储和计算，而MyBatis是存储领域的利器。MyBatis的基本工作原理就是：先封装SQL，接着调用JDBC操作数据库，最后把数据库返回的表结果封装成Java类。</p> <p>（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。</p> <p>（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml
文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p> <p>（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。</p> <p>（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。</p> <p>（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。</p> <p>（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。</p> <p>（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。</p> <p>（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。</p> <h6 id="面-工作原理"><a href="#面-工作原理" class="header-anchor">#</a> 面：工作原理</h6> <p>关于MyBatis的工作原理，网上的文章是汗牛充栋，但是站长觉得，要结合JDBC来理解MyBatis的工作原理往往才能更透彻。我们知道，JDBC有四个核心对象：</p> <ul><li>DriverManager，用于注册数据库连接</li> <li>Connection，与数据库连接对象</li> <li>Statement/PrepareStatement，操作数据库SQL语句的对象</li> <li>ResultSet，结果集或一张虚拟表</li></ul> <p>而MyBatis也有四大核心对象：</p> <ul><li>SqlSession对象，该对象中包含了执行SQL语句的所有方法。类似于JDBC里面的Connection。</li> <li>Executor接口，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。类似于JDBC里面的Statement/PrepareStatement。</li> <li>MappedStatement对象，该对象是对映射SQL的封装，用于存储要映射的SQL语句的id、参数等信息。</li> <li>ResultHandler对象，用于对返回的结果进行处理，最终得到自己想要的数据格式或类型。可以自定义返回类型。</li></ul> <h6 id="面-延迟加载时用及原理"><a href="#面-延迟加载时用及原理" class="header-anchor">#</a> 面：延迟加载时用及原理</h6> <p>Mybatis支持延迟记载，但默认没有开启。</p> <p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载。</p> <p>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载。</p> <p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p> <p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</p> <p>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false，默认是关闭的</p> <ul><li><p>使用CGLIB创建目标对象的代理对象</p></li> <li><p>当调用目标方法user.getOrderList()时，进入拦截器invoke方法，发现user.getOrderList()是null值，执行sql查询order列表</p></li> <li><p>把order查询上来，然后调用user.setOrderList(List<Order> orderList) ，接着完成user.getOrderList()方法的调用</Order></p></li></ul> <p>1、使用CGLIB创建目标对象的代理对象</p> <p>2、当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询</p> <p>3、获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p> <h6 id="面-一级、二级缓存"><a href="#面-一级、二级缓存" class="header-anchor">#</a> 面：一级、二级缓存</h6> <p>本地缓存，基于PerpetualCache，本质是一个HashMap</p> <p>一级缓存：作用域是session级别 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为
Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p> <p>二级缓存：作用域是namespace和mapper的作用域，不依赖于session 二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL
session，默认也是采用 PerpetualCache，HashMap 存储</p> <p><strong>注意事项</strong></p> <p>1、对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有
select 中的缓存将被 clear</p> <p>2、二级缓存需要缓存的数据实现Serializable接口</p> <p>3、只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</p> <h6 id="面-mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#面-mybatis的二级缓存什么时候会清理缓存中的数据" class="header-anchor">#</a> 面：Mybatis的二级缓存什么时候会清理缓存中的数据</h6> <p>当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被
clear。</p> <h4 id="mybaits-plus"><a href="#mybaits-plus" class="header-anchor">#</a> mybaits-plus</h4> <h3 id="mysql"><a href="#mysql" class="header-anchor">#</a> MySQL</h3> <h4 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h4> <h6 id="面-如何定位慢查询"><a href="#面-如何定位慢查询" class="header-anchor">#</a> 面：如何定位慢查询</h6> <p><strong>原因</strong>：</p> <p>聚合查询 添加临时表</p> <p>多表查询 优化sql语句的结构</p> <p>表数据量过大查询 添加索引 分析sql语句 —— 以上都可以用SQL执行计划</p> <p>深度分页查询</p> <p><strong>表象</strong>：页面加载过慢，接口压测响应时间过长，超过1s</p> <p><strong>解决方案1</strong>：开源工具：arthas 运维工具：Prometheus、Skywalking</p> <p><strong>解决方案2</strong>：MySQL自带的慢日志</p> <p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p> <p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>回答</strong>：</p> <p><em>1、介绍一下当时产生问题的场景（我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟）
2.我们系统中当时采用了运维工具（ Skywalking ），可以监测出哪个接口，最终因为是sql的问题</em> <em>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中（调试阶段）</em></p> <h6 id="面-sql执行很慢-如何分析"><a href="#面-sql执行很慢-如何分析" class="header-anchor">#</a> 面：SQL执行很慢，如何分析</h6> <p><strong>很秀</strong></p> <p>可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息</p> <p>type 这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、 index、all</p> <ul><li><p>system：查询系统中的表</p></li> <li><p>const：根据主键查询</p></li> <li><p>eq_ref：主键索引查询或唯一索引查询</p></li> <li><p>ref：索引查询</p></li> <li><p>range：范围查询</p></li> <li><p>index：索引树扫描 —— 后面两个sql需要优化</p></li> <li><p>all：全盘扫描</p></li></ul> <p><strong>回答</strong>：</p> <p><em>可以采用MySQL自带的分析工具
EXPLAIN。通过key和key_len检查是否命中了索引（索引本身存在是否有失效的情况）；通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，通过extra建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</em></p> <h6 id="面-mysql支持的存储引擎有哪些-有什么区别"><a href="#面-mysql支持的存储引擎有哪些-有什么区别" class="header-anchor">#</a> 面：MYSQL支持的存储引擎有哪些, 有什么区别？</h6> <h4 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h4> <h6 id="面-索引在项目中的使用方式"><a href="#面-索引在项目中的使用方式" class="header-anchor">#</a> 面：索引在项目中的使用方式</h6> <p>一是验证你的项目场景的真实性，二是为了作为深入发问的切入点。缓存、分布式锁、消息队列、延迟队列</p> <h6 id="面-什么是索引"><a href="#面-什么是索引" class="header-anchor">#</a> 面：什么是索引</h6> <p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构（B+树），这些数据结构以某种方式引用（指向）数据，
这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p> <p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数（max-degree）为5(5阶)
的b-tree为例，那这个B树每个节点最多存储4个key。</p> <p>B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p> <p>B树与B+树对比:①：磁盘读写代价B+树更低；②：查询效率B+树更加稳定；③：B+树便于扫库和区间查询</p> <h6 id="面-聚簇索引和非聚簇索引"><a href="#面-聚簇索引和非聚簇索引" class="header-anchor">#</a> 面：聚簇索引和非聚簇索引</h6> <p>ps：什么是聚集索引，什么是二级索引（非聚集索引）</p> <table><thead><tr><th>分类</th> <th>含义</th> <th>特点</th></tr></thead> <tbody><tr><td>聚集索引(Clustered  Index)</td> <td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td> <td>必须有,而且只有一个</td></tr> <tr><td>二级索引(Secondary  Index)</td> <td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td> <td>可以存在多个</td></tr></tbody></table> <p>聚集索引选取规则:</p> <ul><li><p>如果存在主键，主键索引就是聚集索引。</p></li> <li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li> <li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul> <p><strong>回答</strong>：</p> <p><em>聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个</em> <em>非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个。</em></p> <h6 id="面-回表查询"><a href="#面-回表查询" class="header-anchor">#</a> 面：回表查询</h6> <p>通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表。</p> <h6 id="面-覆盖索引"><a href="#面-覆盖索引" class="header-anchor">#</a> 面：覆盖索引</h6> <p><strong>回答</strong>：覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p> <ul><li><p>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p></li> <li><p>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *</p></li></ul> <h6 id="面-mysql超大分页"><a href="#面-mysql超大分页" class="header-anchor">#</a> 面：MySQL超大分页</h6> <p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p> <p>select *
from tb_sku t,
(select id from tb_sku order by id limit 9000000,10) a
where t.id = a.id;</p> <h6 id="面-索引创建原则有哪些"><a href="#面-索引创建原则有哪些" class="header-anchor">#</a> 面：索引创建原则有哪些</h6> <p><strong>简答：</strong></p> <ul><li><p>先陈述自己在实际的工作中是怎么用的</p></li> <li><p>主键索引</p></li> <li><p>唯一索引</p></li> <li><p>根据业务创建的索引(复合索引)</p></li></ul> <p><strong>精答：</strong></p> <p>1). 针对于数据量较大，且查询比较频繁的表建立索引。 如：<strong>单表超过10w数据，提升用户体验</strong></p> <p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p> <p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 如：地址address区分度不高</p> <p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 如：商品描述</p> <p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。 如：</p> <p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p> <p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p> <h6 id="面-什么情况下索引会失效"><a href="#面-什么情况下索引会失效" class="header-anchor">#</a> 面：什么情况下索引会失效</h6> <p>1、违反最左前缀法则</p> <p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：</p> <p>违法最左前缀法则 ， 索引失效</p> <p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效</p> <p>2、范围查询右边的列，不能使用索引</p> <p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引</p> <p>3、不要在索引列上进行运算操作， 索引将失效</p> <p>4、字符串不加单引号，造成索引失效。 <strong>类型转换</strong></p> <p>在查询时，没有对字符串加单引号， MySQL的查询优化器，会自动的进行类型转换，造成索引失效</p> <p>5、以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p> <p>6、索引下推</p> <h6 id="面-谈谈你对sql的优化的经验"><a href="#面-谈谈你对sql的优化的经验" class="header-anchor">#</a> 面：谈谈你对sql的优化的经验</h6> <p>表的设计优化、索引优化、SQL语句优化、主从复制、读写分离、分库分表</p> <p><strong>表的设计优化</strong></p> <p>①比如设置合适的数值（tinyint int bigint），要根据实际情况选择</p> <p>②比如设置合适的字符串类型（char和varchar）char定长效率高，varchar可变长度，效率稍低</p> <p><strong>SQL语句优化</strong></p> <p>①SELECT语句务必指明字段名称（避免直接使用select * ）</p> <p>②SQL语句要避免造成索引失效的写法</p> <p>③尽量用union all代替union union会多一次过滤，效率低</p> <p>④避免在where子句中对字段进行表达式操作</p> <p>⑤Join优化 能用innerjoin 就不用left join right join，如必须使用 一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。left
join 或 right join，不会重新调整顺序</p> <p><strong>主从复制、读写分离</strong></p> <p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。</p> <p>读写分离解决的是，数据库的写入，影响了查询的效率。</p> <h4 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h4> <h6 id="面-事务的特性是什么"><a href="#面-事务的特性是什么" class="header-anchor">#</a> 面：事务的特性是什么</h6> <p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p> <p><strong>ACID</strong></p> <p>ACID是指数据库事务的四个特性，它们分别是：</p> <ol><li>Atomicity（原子性）：事务是一个原子操作，要么全部执行，要么全部不执行。如果执行过程中出现错误，则事务会被回滚到初始状态，撤销已经执行的操作。</li> <li>Consistency（一致性）：事务在执行前后，数据库的约束条件（例如唯一性约束、外键）必须保持一致，保证数据的正确性和合法性。</li> <li>Isolation（隔离性）：同时运行的多个事务之间是相互隔离的，一个事务的执行过程不会影响其他事务，保证了数据的独立性和隔离性。</li> <li>Durability（持久性）：事务完成后，对数据的更改必须保证永久性，即使系统崩溃或重启，数据也不会丢失。</li></ol> <p>这四个特性是保证数据库系统可靠性、稳定性、一致性的基础，也是衡量数据库系统质量的重要标准之一。</p> <h6 id="面-并发事务带来哪些问题、如何解决这些问题呢、mysql的默认隔离级别"><a href="#面-并发事务带来哪些问题、如何解决这些问题呢、mysql的默认隔离级别" class="header-anchor">#</a> 面：并发事务带来哪些问题、如何解决这些问题呢、MySQL的默认隔离级别</h6> <p><strong>并发事务问题</strong>：脏读、不可重复读、幻读</p> <table><thead><tr><th><strong>问题</strong></th> <th><strong>描述</strong></th></tr></thead> <tbody><tr><td>脏读</td> <td>一个事务读到另外一个事务还没有提交的数据。</td></tr> <tr><td>不可重复读</td> <td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr> <tr><td>幻读</td> <td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</td></tr></tbody></table> <p><strong>隔离级别</strong>：读未提交、读已提交、可重复读、串行化</p> <table><thead><tr><th>隔离级别</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th></tr></thead> <tbody><tr><td>Read  uncommitted  未提交读</td> <td>√</td> <td>√</td> <td>√</td></tr> <tr><td>Read  committed 读已提交</td> <td>×</td> <td>√</td> <td>√</td></tr> <tr><td>Repeatable  Read(默认) 可重复读</td> <td>×</td> <td>×</td> <td>√</td></tr> <tr><td>Serializable  串行化</td> <td>×</td> <td>×</td> <td>×</td></tr></tbody></table> <p>解决方案：对事务进行隔离</p> <p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p> <h6 id="面-undo-log和redo-log的区别"><a href="#面-undo-log和redo-log的区别" class="header-anchor">#</a> 面：undo log和redo log的区别</h6> <p><strong>redolog</strong></p> <p>重做日志，记录的是事务提交时数据页的物理修改，是<em>用来实现事务的持久性</em>。</p> <p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log
file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时,
进行数据恢复使用。</p> <p><strong>undolog</strong></p> <p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚 和 MVCC(多版本并发控制) 。undo log和redo
log记录物理日志不一样，它是逻辑日志。</p> <ul><li><p>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，</p></li> <li><p>当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p></li></ul> <p>注意：undo log可以实现事务的一致性和原子性</p> <p><strong>回答：</strong></p> <ul><li><p>redo log: 记录的是数据页的物理变化，服务宕机可用来同步数据</p></li> <li><p>undo log ：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</p></li> <li><p>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</p></li></ul> <h6 id="面-事务中的隔离性是如何保证"><a href="#面-事务中的隔离性是如何保证" class="header-anchor">#</a> 面：事务中的隔离性是如何保证</h6> <p>锁：排他锁（如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁）</p> <p>mvcc : 多版本并发控制</p> <h6 id="面-介绍mvvc-难"><a href="#面-介绍mvvc-难" class="header-anchor">#</a> 面：介绍MVVC ~难</h6> <p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p> <p>MVCC的具体实现，主要依赖于数据库记录中的隐式字段、undo log日志、readView。</p> <p><strong>隐式字段</strong></p> <p><strong>Undo Log日志</strong></p> <p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p> <p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p> <p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</p> <p><strong>read view</strong></p> <h4 id="主从同步"><a href="#主从同步" class="header-anchor">#</a> 主从同步</h4> <h6 id="面-mysql主从同步原理"><a href="#面-mysql主从同步原理" class="header-anchor">#</a> 面：MySQL主从同步原理</h6> <p><strong>原理图</strong></p> <p><strong>二进制日志</strong></p> <p>MySQL主从复制的核心就是二进制日志binlog(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)</p> <p>1、主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p> <p>2、从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p> <p>3、从库重做中继日志中的事件，将改变反映它自己的数据</p> <h4 id="分库分表"><a href="#分库分表" class="header-anchor">#</a> 分库分表</h4> <h6 id="面-分库分表遇到过吗"><a href="#面-分库分表遇到过吗" class="header-anchor">#</a> 面：分库分表遇到过吗</h6> <ul><li>分库分表的时机：</li></ul> <p>1、<em>前提</em>，项目业务数据逐渐增多，或业务发展比较迅速 ——单表的数据量达<strong>1000W</strong>或<strong>20G</strong>以后</p> <p>2、优化已解决不了性能问题（主从读写分离、查询索引…）</p> <p>3、IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</p> <ul><li>业务介绍</li></ul> <p>1、根据自己简历上的项目，想一个数据量较大业务（请求数多或业务累积大）</p> <p>2、达到了什么样的量级（单表1000万或超过20G）</p> <ul><li>具体拆分策略</li></ul> <p>1、水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题</p> <p>2、水平分表，解决单表存储和性能的问题</p> <p>3、垂直分库，根据业务进行拆分，高并发下提高磁盘IO和网络连接数</p> <p>4、垂直分表，冷热数据分离，多表互不影响</p> <h3 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h3> <h5 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h5> <h6 id="面-缓存穿透"><a href="#面-缓存穿透" class="header-anchor">#</a> 面：缓存穿透</h6> <p>查询不存在的数据。</p> <p><strong>解决方案</strong>：</p> <p>1、缓存控制 设置消失时间</p> <p>2、布隆过滤</p> <h6 id="面-缓存击穿"><a href="#面-缓存击穿" class="header-anchor">#</a> 面：缓存击穿</h6> <p>给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB打垮</p> <p>1、逻辑过期 高可用、性能优</p> <p>2、互斥锁 强一致、性能差</p> <h6 id="面-缓存雪崩"><a href="#面-缓存雪崩" class="header-anchor">#</a> 面：缓存雪崩</h6> <p>**原因：**同一时间大量缓存的key同时失效，因为设置了相同的过期时间，或者Rdis服务宕机，导致大量请求到达数据库，带来巨大压力</p> <p><strong>解决方案</strong>：</p> <ul><li><p>给不同的key的TTL添加随机值</p></li> <li><p>利用redis集群提高服务的可用性</p></li> <li><p>给缓存业务添加降级限流策略 系统保底策略 可用于雪崩 击穿 穿透</p></li> <li><p>给业务添加多级缓存</p></li></ul> <h6 id="面-双写一致"><a href="#面-双写一致" class="header-anchor">#</a> 面：双写一致</h6> <p>注意：一定要设置前提，先介绍自己的业务背景</p> <p><strong>一致性要求高</strong></p> <p>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据保持一致</p> <p>读操作：缓存命中，直接返回；缓存为命中查询数据库，写入缓存，设定超时时间</p> <p>写操作：延迟双删</p> <p>*先删除缓存，再操作数据库：*缓存拿到的是数据库的旧数据，而数据库就要更新数据了</p> <p>*先操作数据库，再删除缓存：*缓存拿到的是数据库的旧数据，数据库更新，删除缓存，再写入缓存还是脏数据</p> <h6 id="面-redis作为缓存-数据持久化是怎么做的"><a href="#面-redis作为缓存-数据持久化是怎么做的" class="header-anchor">#</a> 面：Redis作为缓存，数据持久化是怎么做的</h6> <p><strong>RDB</strong></p> <p>redis database Backup file，redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘。当redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p> <p>save/bgsave：推荐使用子进程进行RDB，避免主进程受到影响</p> <p>执行原理：异步，子进程共享主进程的内存数据，完成fork后读取内存并写入RDB文件</p> <p>页表：记录虚拟地址和物理地址的映射关系 （计算机组成原理）</p> <p><strong>AOF</strong></p> <p>追加文件。Redis处理每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p> <p><strong>对比</strong></p> <table><thead><tr><th></th> <th><strong>RDB</strong></th> <th><strong>AOF</strong></th></tr></thead> <tbody><tr><td>持久化方式</td> <td>定时对整个内存做快照</td> <td>记录每一次执行的命令</td></tr> <tr><td>数据完整性</td> <td>不完整，两次备份之间会丢失</td> <td>相对完整，取决于刷盘策略</td></tr> <tr><td>文件大小</td> <td>会有压缩，文件体积小</td> <td>记录命令，文件体积很大</td></tr> <tr><td>宕机恢复速度</td> <td>很快</td> <td>慢</td></tr> <tr><td>数据恢复优先级</td> <td>低，因为数据完整性不如AOF</td> <td>高，因为数据完整性更高</td></tr> <tr><td>系统资源占用</td> <td>高，大量CPU和内存消耗</td> <td>低，主要是磁盘IO资源  但AOF重写时会占用大量CPU和内存资源</td></tr> <tr><td>使用场景</td> <td>可以容忍数分钟的数据丢失，追求更快的启动速度</td> <td>对数据安全性要求较高常见</td></tr></tbody></table> <h6 id="面-数据过期"><a href="#面-数据过期" class="header-anchor">#</a> 面：数据过期</h6> <p><strong>数据删除策略</strong></p> <p>惰性删除：过期删除，没扫描到就没删除，对CPU友好，对内存不友好</p> <p>定期删除：每隔一段时间，就对一批key进行检查，两种模式slow和fast</p> <p>策略就是：惰性+定期</p> <h6 id="面-数据淘汰"><a href="#面-数据淘汰" class="header-anchor">#</a> 面：数据淘汰</h6> <p><strong>数据淘汰策略</strong></p> <p><strong>简答：</strong></p> <p>1.Redis提供了8种不同的数据淘汰策略，默认是noeviction不删除任何数据，内存不足直接报错</p> <p>2.LRU：最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p> <p>3.LFU：最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</p> <p>平时开发过程中用的比较多的就是allkeys-lru（结合自己的业务场景）</p> <h5 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h5> <h6 id="面-使用场景"><a href="#面-使用场景" class="header-anchor">#</a> 面：使用场景</h6> <p>抢券，集群部署模拟，nginx反向代理负载均衡</p> <h6 id="面-实现原理"><a href="#面-实现原理" class="header-anchor">#</a> 面：实现原理</h6> <p>setnx 数据结构实现的</p> <p>还有redisson分布式锁</p> <p>del命令 -释放锁</p> <p>redis实现分布式锁如何合理的控制锁的有效时长？</p> <p>业务超时或者服务宕机情况 解决：1、根据业务执行时间预估 2、给锁续期</p> <p>第一个不好控制 第二个更合理</p> <p>就是redisson实现的分布式锁-执行流程</p> <p>加锁成功 操作redis 第二线程会每个releasetime/3的时间做一次续期 重置过期时间</p> <p>手动释放锁 通知对应的watchdog就行</p> <p>不仅仅如此 新的线程也是 先加锁 成功去执行业务 没成功就会while循环 不断尝试获取锁 设定一个阈值 没成功就算了 加入等待机制
可以在高并发的情况下</p> <p>加锁，设置过期时间等操作都是基于lua脚本完成的</p> <p>redisson的锁是否可重入呢？</p> <p>根据线程id进行判断 如果是同一个线程就可以成功 如果不是就会失败</p> <p>跟多线程的undolog就是一样的 可以避免多个锁出现死锁的情况 利用hash结构记录线程id和重入次数</p> <p>可重入逻辑讲解 就是 线程里面会调用 其他方法 这个方法用的锁和该线程的锁是一致的</p> <p>分布式锁能保证 主从一致性吗？</p> <p>主节点和从节点 主就是写 从就是读</p> <p>正常情况 获取锁给主节点 主节点挂了 那就从节点顶上 那么其他业务也能拿到锁</p> <p>红锁解决，不能只在一个redis实例上创建锁，应该是多个redis实例上创建n/2 + 1，避免一个redis实例上加锁 实现比较复杂 性能差 运维繁琐</p> <p>低概率事件 强一致性 用CP思想 zookeeper</p> <p>我们就是AP思想 redis</p> <h6 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h6> <p>做过的业务进行分布式锁使用的场景</p> <p>redisson实现的分布式锁 底层setnx和lua脚本</p> <p>还有一个看门狗机制 默认10秒续期一次</p> <p>可以重入嘛 可以重入 判断线程id是不是一致 hash结构</p> <p>不能解决主从数据一致的问题 红锁性能低 非要保证只能用CP思想 zookeeper</p> <h5 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h5> <p>redis集群有哪些方案？</p> <h6 id="面-主从复制"><a href="#面-主从复制" class="header-anchor">#</a> 面：主从复制</h6> <p>单节点redis的并发能力是有上限的，要进一步提高redis的并发能力，就需要搭建主从集群，实现读写分离</p> <p>主节点和从节点 主节点写 同步给 从节点读</p> <p>主从同步流程：</p> <p>1.主从<strong>全量同步</strong> 执行relicaof命令建立连接 从向主 请求数据同步 判断是否是第一次同步 是第一次 返回master的数据版本信息
保存版本信息 执行bgsave 生成RDB 发送给从节点 清空本地数据 加载RDB文件</p> <p>如果又来了新的请求 那么日志会记录所有命令 发送repl baklog中的命令 执行接收到的命令</p> <p><strong>replication id</strong>：数据集标记 id一致 master一个 从节点继承</p> <p><strong>offset</strong>：偏移量，记录在日志中的数据增多，也会同步，如果从节点的偏移量小于主节点的偏移量，说明从节点的版本落后</p> <p>随便吹吧 太多了</p> <p>2.主从<strong>增量同步</strong> 从节点重启或后期数据变化</p> <p>重启 判断 第一次与否 日志获取 偏移量考察 执行命令</p> <p>总结：</p> <p>巴拉巴拉 太多了 主要是增量同步和全量同步</p> <h6 id="面-哨兵模式"><a href="#面-哨兵模式" class="header-anchor">#</a> 面：哨兵模式</h6> <p>redis提供了哨兵机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p> <p>监控：sentinel会不断检查主节点和从节点是否按预期工作</p> <p>自动故障恢复：如果master故障，sentinel会将一个salve提升为master。当故障实例恢复后也以新的master为主</p> <p>同住：sentinel充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给redis的客户端</p> <p>服务状态监控</p> <p>sentinel基于心态监测服务状态，每隔一秒向集群的每个实例发送ping命令：</p> <ul><li>主观下线：如果其sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线</li> <li>客观下线：若超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量一半</li></ul> <p>哨兵选主规则</p> <ul><li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li> <li>然后判断从节点的优先值，越小优先级越高</li> <li>如果优先值相同，则判断从节点的offset值，越大优先级越高</li> <li>最后是判断slave节点的运行id大小，越小优先级越高</li></ul> <p>脑裂</p> <h6 id="面-分片集群、数据读写规则"><a href="#面-分片集群、数据读写规则" class="header-anchor">#</a> 面：分片集群、数据读写规则</h6> <p>解决写多读少</p> <p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p> <ul><li>海量数据存储问题</li> <li>高并发写的问题</li></ul> <p>使用分片集群可以解决上述问题，分片集群特质：</p> <ul><li>集群中有多个master，每个master保存不同数据</li> <li>每个master都可以有多个slave节点</li> <li>master之间通过ping监测彼此健康状态</li> <li>redis可以访问任意个节点 任意路由 最终会被转发到正确节点</li></ul> <p>分片集群结构-数据读写</p> <p>redis分片集群引入了哈希槽的概念，redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责异步hash槽</p> <p>读写数据：根据key的有效部分计算hash值，对16384取余(
有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身作为有效部分)余数作为插槽，寻找插槽所在的实例</p> <h6 id="面-redis是单线程的-为什么还那么快"><a href="#面-redis是单线程的-为什么还那么快" class="header-anchor">#</a> 面：redis是单线程的，为什么还那么快</h6> <ul><li>纯内存操作，执行速度非常快</li> <li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li> <li>使用I/O多路复用模型，非阻塞IO</li></ul> <p>解释一下I/O多路复用模型</p> <p>redis是纯内存操作，性能瓶颈是网络延迟而不是执行速度，io多路复用模型就是实现了高效的网络请求</p> <p>用户空间和内核空间 常见的io模型-阻塞io 非阻塞io io多路复用 redis网络模型</p> <p>用户空间和内核空间</p> <p>linux系统中一个进程使用的内存情况划分为两部分：内核空间、用户空间</p> <p>用户空间只能执行受限的命令，不能直接调用系统资源，必须通过内核提供的接口来访问</p> <p>内核空间可以执行特权命令，调用一起系统资源</p> <p>硬件 网卡 用户空间-内核空间-硬件</p> <p>linux为了提高io小笼包，会加入缓冲区：</p> <p>写数据时，把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p> <p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p> <p>阻塞IO</p> <p>就是两个阶段都必须阻塞等待</p> <p>阶段1：用户尝试读数据，数据没到达，内核需要等待数据，此时用户进程也处于阻塞状态</p> <p>阶段2：数据到达并拷贝到内核缓冲区，代表已就绪，内核数据拷贝到用户缓冲区，拷贝过程中，用户阻塞，拷贝完成后，用户开始处理数据</p> <p>可以看到用户进程在两个阶段都是阻塞状态</p> <p>非阻塞IO</p> <p>非阻塞IO的revfrom操作会立即返回结果而不是阻塞用户进程</p> <p>阶段一：</p> <p>1、用户进程尝试读取数据</p> <p>2、数据尚未到达，内核需要等待数据</p> <p>3、返回异常给用户进程</p> <p>4、用户进程拿到error后，再次尝试读取</p> <p>5、循环往复，直到数据就绪</p> <p>阶段二：</p> <p>1、将内核数据拷贝到用户缓冲区</p> <p>2、拷贝过程中，用户进程依然阻塞等待</p> <p>3、拷贝完成，用户进程解决阻塞，处理数据</p> <p>可以看到，非阻塞io模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态，但是性能没有提高。而且忙等机制会导致cpu空转，cpu的使用率暴增</p> <p>io多路复用</p> <p>是利用单个线程来同时监听多个socket，并在某个soket可读，可写时得到通知，从而避免无效的等待，充分利用cpu资源</p> <p>阶段1：</p> <p>1.用户进程调用select，指定要监听的socket集合</p> <p>2.内核监听对应的多个socket</p> <p>3.任意一个或多个socket数据就绪就返回readable</p> <p>4.此过程中用户进程阻塞</p> <p>阶段2：</p> <p>1.用户进程找到就绪的socket</p> <p>2.依次低啊用recvfrom读取数据</p> <p>3.内核将数据拷贝到用户空间</p> <p>4.用户进程处理数据</p> <p>IO多路复用</p> <p>io多路复用是利用单个线程来监听多个socket，并在某个socket可读，可写是得到用户，从而避免无效的等待，充分利用CPU资源，不过监听socket的方式，通知的方式有有很多种实现，常见的有：</p> <p>select</p> <p>poll</p> <p>epoll</p> <p>差异：</p> <p>select和poll只会通知用户进程有socket就绪，但不确定具体是哪个socket，需要用户进程逐个遍历socket来确认</p> <p>epoll则会在通知用户继承socket就绪同时，把已就绪的socket写入用户空间</p> <p>redis网络模型</p> <p>netty模型？？ 有人提的</p> <p>通过IO多路复用来提高网络性能，并且支持各种不同的的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库</p> <p>连接应答处理器 命令回复处理器 命令请求处理器</p> <p>多线程 接收请求数据 将数据转为redis命令 选择并执行命令把结果写入缓冲队列</p> <p><strong>总结</strong></p> <p>io多路复用</p> <p>redis网络模型</p> <h6 id="面-五连问"><a href="#面-五连问" class="header-anchor">#</a> 面：五连问</h6> <ol><li>Redis和MySQL如何保证数据一致性？</li> <li>Redis中的数据如何与MySQL保持同步？</li> <li>MySQL出现故障时，Redis会如何处理数据的一致性？</li> <li>如何避免Redis和MySQL之间的数据误差？</li> <li>Redis如何处理MySQL中的更新和删除操作？</li></ol> <p>1、Redis和MySQL可以通过以下方法来保证数据一致性：</p> <ul><li>应用程序需要使用同一套数据读写模型，如读写都通过Redis进行，或者读写都通过MySQL进行。</li> <li>应用程序需要处理好在读写过程中发生的异常情况，如Redis和MySQL服务器宕机、网络故障、数据转移等。</li> <li>在从Redis中读取数据和从MySQL中读取数据之间引入一层缓存层，如memcached，可以有效提高系统的读取效率和稳定性。</li></ul> <p>2、Redis和MySQL的数据同步可以通过以下方式实现：</p> <ul><li>周期性地将MySQL的数据通过程序同步到Redis中，并保持两者数据的一致性。</li> <li>利用Redis的订阅/发布功能，在MySQL中有数据变化时主动通知Redis进行更新。</li> <li>还可以在程序设计时使用分布式锁和队列等技术，通过消息队列将Redis和MySQL的数据进行同步。</li></ul> <p>3、</p> <p>当MySQL出现故障时，Redis会根据配置选择采取不同的处理策略。可以选择继续让Redis提供被缓存数据的服务，或者禁止Redis提供服务。一般情况下，为了保证数据的完整性和一致性，应该停止Redis的服务，等MySQL恢复后再重新同步数据。</p> <p>4、避免Redis和MySQL之间的数据误差，需要做好以下几点：</p> <ul><li>数据存储之前进行有效性校验，以确保数据的正确性。</li> <li>对于涉及多个操作的业务，需要使用分布式事务保证数据操作的原子性。</li> <li>采用一致性哈希算法等分布式数据存储方案，平衡集群节点的负载和数据分布，减少数据误差的可能性。</li> <li>应用程序中需要正确处理Redis和MySQL之间的数据同步操作，保证数据的一致性。</li></ul> <p>5、Redis可以通过以下方式处理MySQL中的更新和删除操作：</p> <ul><li>在MySQL数据库发生更新或删除操作时，需要将对应的key从Redis中删除，避免旧数据的残留。</li> <li>如果需要对Redis中的缓存数据进行更新或删除操作，可以使用Redis提供的命令进行操作，如SET和DEL命令。这样可以避免MySQL和Redis之间数据同步不一致的问题。</li></ul> <h3 id="微服务"><a href="#微服务" class="header-anchor">#</a> 微服务</h3> <h4 id="springcloud"><a href="#springcloud" class="header-anchor">#</a> springcloud</h4> <p>常用组件有哪些</p> <p>5大组件：</p> <p>Eureka 注册中心-配置中心</p> <p>gateway 网关</p> <p>feign 远程调用</p> <p>ribbon 负载均衡</p> <p>hystric 服务熔断</p> <p>springcloudAlibaba：</p> <p>nacos</p> <p>ribbon</p> <p>feign</p> <p>sentinel 服务保护</p> <p>gateway 服务网关</p> <h5 id="服务注册"><a href="#服务注册" class="header-anchor">#</a> 服务注册</h5> <h6 id="面-服务注册和发现是什么意思-springcloud如何实现服务注册发现"><a href="#面-服务注册和发现是什么意思-springcloud如何实现服务注册发现" class="header-anchor">#</a> 面：服务注册和发现是什么意思？springcloud如何实现服务注册发现？</h6> <p>微服务必须要使用的组件，考察我们使用微服务的程度</p> <p>注册中心的核心作用是：服务注册和发现</p> <p>常见的注册中心：eureka、nacos、zookeeper</p> <p>我做过xx项目</p> <p>下单 远程调用 拿到用户的数据 需要用到注册中心 可能有多台服务器</p> <p>Eureka 作用</p> <p>1、注册服务信息 服务提供者</p> <p>2、拉取服务的信息 服务消费者</p> <p>3、负载均衡</p> <p>4、远程调用</p> <p>定期向注册中心 发送心跳续约 如果断了 服务列表就把断了的清掉</p> <p>所以也有健康监测的作用</p> <p><strong>总结</strong>：</p> <p>1.服务注册 服务提供者把自己的信息注册到eureka，它来保存，比如服务名称ip、端口等</p> <p>2.服务发现 消费者拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</p> <p>3.服务监控 服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90s没接收到心跳，从eureka中剔除</p> <p><strong>nacos 作用？</strong></p> <p>和eureka的区别 共同点</p> <p>nacos工作流程</p> <p>服务提供者注册服务信息 定时拉取服务pull服务消费者 远程调用服务提供者 临时实例采用心跳监测 非临时实例nacos主动询问
可以在application.yml进行配置 还能主动变更消息push</p> <p><strong>区别</strong></p> <p>相同：都支持服务注册和服务拉取 都支持服务提供者心跳做健康监测</p> <p>不同：监测状态方式不同 保留实例方式不同 消息推送方式不同 集群默认采用方式不同思想会变</p> <p>nacos还多了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因</p> <h5 id="负载均衡"><a href="#负载均衡" class="header-anchor">#</a> 负载均衡</h5> <h6 id="问-负载均衡如何实现"><a href="#问-负载均衡如何实现" class="header-anchor">#</a> 问：负载均衡如何实现</h6> <p>负载均衡ribbon，发起远程调用feign就会使用ribbon</p> <p>订单微服务 和 用户微服务</p> <p>发起请求 指定某一个服务 调用ribbon负载均衡 从注册中心拉取服务提供者消息 然后将服务提供者按照负载均衡分配给服务消费者</p> <p>策略如果是轮询</p> <p>ribbon的负载均衡策略有哪些？</p> <p>roundRobinRule：简单轮询</p> <p>WeightedResposeTimeRule：权重来选择服务器</p> <p>RandomRule：随机策略</p> <p>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器</p> <p>RetryRule：重试机制的选择逻辑</p> <p>AvaliablilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的策略</p> <p>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。机房，轮询</p> <h6 id="如何自定义服务在均衡策略"><a href="#如何自定义服务在均衡策略" class="header-anchor">#</a> 如何自定义服务在均衡策略</h6> <p>自己创建类IRule接口，然后通过配置类或者配置文件配置即可，通过IRule实现可以修改负载均衡规则，有两种方式</p> <p>yml文件或者配置类 前局部生效 后全局生效</p> <p>区域敏策略，服务器的就近原则</p> <h5 id="服务雪崩、熔断降级"><a href="#服务雪崩、熔断降级" class="header-anchor">#</a> 服务雪崩、熔断降级</h5> <h6 id="什么事服务雪崩"><a href="#什么事服务雪崩" class="header-anchor">#</a> 什么事服务雪崩</h6> <p>某一个服务挂了 可能导致服务雪崩 连锁反应</p> <p>解决 熔断降级</p> <p>预防 限流</p> <p><strong>服务降级</strong></p> <p>服务自我保护的一种方式，或保护下游服务的一种方式，用于确保服务不受请求突增影响而变得不可用，确保服务不会崩溃正常可以走就是调用
如果失败就是fallback 获取数据失败 如果降级过多 则会触发熔断机制</p> <h5 id="服务熔断"><a href="#服务熔断" class="header-anchor">#</a> 服务熔断</h5> <p>默认关闭 需要开始时在引导类上添加注解 如果监测到10s内请求的失败率超过50% 就触发熔断机制。</p> <p>之后每隔5s尝试重新请求微服务，如果微服务不能响应，继续走熔断机制</p> <p>如果微服务可达 则关闭熔断机制，恢复正常请求</p> <h4 id="微服务的监控"><a href="#微服务的监控" class="header-anchor">#</a> 微服务的监控</h4> <h5 id="监控"><a href="#监控" class="header-anchor">#</a> 监控</h5> <p>问题定位！性能分析！服务关系！服务告警！</p> <p>PC APP 小程序 其他 》网关》服务》各种开发软件</p> <p>springboot-admin 状态信息 功能简单 单一</p> <p>prometheus+Grafanna 全面 强大 搭建起来复杂</p> <p>zipkin 链路追踪工具 耦合度高</p> <p>skywalking 链路追踪根据 也不错</p> <p><strong>skywalking</strong></p> <p>一个分布式系统的应用程序性能监控工具，提供了完整的链路追踪能力</p> <p>服务 ：业务资源应用系统</p> <p>端点：应用系统对外暴露的功能接口</p> <p>实例：物理机</p> <p>全干工程师</p> <p>告警规则如下：</p> <p>……</p> <h4 id="业务相关"><a href="#业务相关" class="header-anchor">#</a> 业务相关</h4> <h5 id="限流"><a href="#限流" class="header-anchor">#</a> 限流</h5> <p>并发大 防止用户恶意刷接口</p> <p>方式：tomcat、网关、nginx、自定义拦截器</p> <p>nginx 控制速率 配置</p> <h5 id="分布式事务"><a href="#分布式事务" class="header-anchor">#</a> 分布式事务</h5> <p>CAP和BASE</p> <p>CAP：一致性 可用性 区分容错性</p> <p>总结：分布式系统节点肯定是需要网络连接的，p必然存在 高可用性，就不能强一致性 一致性，就要放弃高可用性</p> <p>Base理论 对CAP的一种解决</p> <p>基本可用 软状态 最终一致性</p> <h5 id="分布式解决方案"><a href="#分布式解决方案" class="header-anchor">#</a> 分布式解决方案</h5> <h6 id="seata架构"><a href="#seata架构" class="header-anchor">#</a> seata架构</h6> <p>事务协调者</p> <p>事务管理器</p> <p>资源管理器</p> <h6 id="tcc模式"><a href="#tcc模式" class="header-anchor">#</a> tcc模式</h6> <h6 id="mq分布式事务"><a href="#mq分布式事务" class="header-anchor">#</a> mq分布式事务</h6> <h6 id="用任务调度"><a href="#用任务调度" class="header-anchor">#</a> 用任务调度</h6> <h5 id="分布式服务接口幂等"><a href="#分布式服务接口幂等" class="header-anchor">#</a> 分布式服务接口幂等</h5> <p>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</p> <p>需要幂等场景</p> <p>用户重复点击 网络波动</p> <p>mq消息重复</p> <p>应用使用失败或超时机制重试</p> <h6 id="restful"><a href="#restful" class="header-anchor">#</a> Restful</h6> <p>api风格的角度 进行的</p> <p>get 查询天然幂等</p> <p>post 新增操作 不是幂等</p> <p>put 更新操作，不是幂等</p> <p>delete 删除操作，是幂等的</p> <p>数据库的唯一索引 新增</p> <p>token+redis 新增+修改</p> <p>创建商品、提交订单、转账、支付等操作</p> <p>第一次请求 第二次请求 验证</p> <h5 id="分布式任务调度"><a href="#分布式任务调度" class="header-anchor">#</a> 分布式任务调度</h5> <p>分布式任务调度</p> <p>xxl-job</p> <h6 id="当时是什么场景用了任务调度"><a href="#当时是什么场景用了任务调度" class="header-anchor">#</a> 当时是什么场景用了任务调度？</h6> <p>解决集群任务的重复执行问题</p> <p>cron表达式定义灵活</p> <p>定时任务失败了，重试和统计</p> <p>任务量大，分片执行</p> <h6 id="xxl-job路由策略"><a href="#xxl-job路由策略" class="header-anchor">#</a> xxl-job路由策略？</h6> <p>轮询 随机 一致性 最不经常使用 最近最久未使用 故障转移 忙碌转移 分片广播</p> <h6 id="xxl-job任务执行失败怎么解决"><a href="#xxl-job任务执行失败怎么解决" class="header-anchor">#</a> xxl-job任务执行失败怎么解决？</h6> <p>故障转移+失败重试，查看日志分析 邮件告警</p> <p>任务调度中心</p> <p>如果有大数据量的任务同时都需要执行，怎么解决</p> <p>分片广播 一次任务调度</p> <h3 id="消息中间件"><a href="#消息中间件" class="header-anchor">#</a> 消息中间件</h3> <p>rabbitmq 消息不丢失 消息重复消费 消息堆积 延迟队列 死信队列 高可用机制</p> <p>kafka 高性能设计 数据存储和清理 消息不丢失 消息重复消费 高可用机制</p> <h6 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="header-anchor">#</a> 如何保证消息不丢失？</h6> <p>生产者 交换机 队列 消费者</p> <p>生产者确认机制 ack</p> <h6 id="消息失败之后如何处理"><a href="#消息失败之后如何处理" class="header-anchor">#</a> 消息失败之后如何处理？</h6> <p>回调方法即时重发</p> <p>记录日志</p> <p>保存到数据库然后定时重发，成功发送后即可删除表中的数据</p> <h6 id="消息持久化"><a href="#消息持久化" class="header-anchor">#</a> 消息持久化</h6> <p>mq默认是内存存储信息，开启持久化功能可以确保缓存在mQ中的消息不丢失</p> <p>1.交换机持久化</p> <p>2.队列持久化</p> <p>3.消息持久化</p> <h6 id="消费者确认"><a href="#消费者确认" class="header-anchor">#</a> 消费者确认</h6> <p>springAMQP 允许配置三种确认模式</p> <ul><li><p>manual：手动ack，需要在业务代码结束后，调用api发送ack</p></li> <li><p>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack;抛出异常则返回nack</p></li> <li><p>none：关闭ack，mq假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p></li></ul> <p>我们可以利用spring的重试机制，消息投递到异常交换机，由人工处理</p> <h5 id="消息的重复消费如何解决"><a href="#消息的重复消费如何解决" class="header-anchor">#</a> 消息的重复消费如何解决？</h5> <p>原因：网络抖动，消费者挂了</p> <p>业务唯一标识：支付id、订单id、文章id</p> <p>解决方案：</p> <ul><li>每条消息设置一个唯一的标识id</li> <li>幂等方案：分布式锁、数据库锁（乐观锁、悲观锁）</li></ul> <h4 id="rabbitmq"><a href="#rabbitmq" class="header-anchor">#</a> rabbitmq</h4> <h5 id="rabbitmq的死信交换机-延迟队列有了解过嘛"><a href="#rabbitmq的死信交换机-延迟队列有了解过嘛" class="header-anchor">#</a> rabbitmq的死信交换机？延迟队列有了解过嘛？</h5> <p>延迟队列：进入队列的消息会被延迟消费的队列</p> <p>场景：超时订单、限时优惠、定时发布</p> <p>延迟队列=死信交换机+TTL</p> <h6 id="死信交换机"><a href="#死信交换机" class="header-anchor">#</a> 死信交换机</h6> <p>消费者使用reject或nack声明消费失败，并且消息的requeue的参数设置为false</p> <p>消息是一个过期消息，超时无人消费</p> <p>要投递的队列消息堆积满了，最早的消息可能成为死信</p> <p>如果该队列配置了dead-letter-exchang属性，制定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机成为死信交换机（DLX）</p> <h6 id="ttl"><a href="#ttl" class="header-anchor">#</a> TTL</h6> <p>time to live</p> <p>ttl结束了，仍未消费，则会变成死信</p> <p>分两种情况：消息所在的队列设置了存活时间 消息本身设置了存活时间</p> <h6 id="延迟队列插件"><a href="#延迟队列插件" class="header-anchor">#</a> 延迟队列插件</h6> <p>本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可。发送消息时，添加x-delay头，值为超时时间。</p> <h5 id="如果有100万消息堆积在mq怎么解决"><a href="#如果有100万消息堆积在mq怎么解决" class="header-anchor">#</a> 如果有100万消息堆积在mq怎么解决？</h5> <p>生产者发送的消息的速度超过了消费者处理消息的速度，导致队列中的存储消息达到上限。之后发送的消息会就会成为死信，可能会被丢弃，这就是消息堆积问题。</p> <p>增加更多的消费者，提高消费速度。</p> <p>在消费者内开启线程池加快消息处理速度。</p> <p>扩大队列容积，提高堆积上限。</p> <h6 id="惰性队列"><a href="#惰性队列" class="header-anchor">#</a> 惰性队列</h6> <p>接收到消息后直接存入磁盘而非内存。</p> <p>消费者要消费消息时，才会从磁盘中并加载到内存。</p> <p>支持数百万条的消息存储。</p> <h5 id="rabbitmq的高可用机制"><a href="#rabbitmq的高可用机制" class="header-anchor">#</a> rabbitmq的高可用机制</h5> <p>采用集群来保证高可用性</p> <p>普通集群 或者叫标准集群，具备下列特征</p> <p>会在集群的各个节点间共享不符数据，包括：交换机、队列。不包含队列中的消息。</p> <p>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回。</p> <p>队列所在节点宕机，队列中的消息就会丢失。</p> <p>镜像集群</p> <p>仲裁队列</p> <h4 id="kafka"><a href="#kafka" class="header-anchor">#</a> kafka</h4> <h5 id="kafka是如何保证消息不丢失"><a href="#kafka是如何保证消息不丢失" class="header-anchor">#</a> kafka是如何保证消息不丢失</h5> <h5 id="kafka如何保证消息顺序"><a href="#kafka如何保证消息顺序" class="header-anchor">#</a> kafka如何保证消息顺序</h5> <p>指定分区好和业务相同的key</p> <h5 id="kafka的高可用机制有了解吗"><a href="#kafka的高可用机制有了解吗" class="header-anchor">#</a> kafka的高可用机制有了解吗</h5> <p>集群模式</p> <p>分区备份模式</p> <h5 id="数据清理机制"><a href="#数据清理机制" class="header-anchor">#</a> 数据清理机制</h5> <p>kafka存储结构</p> <p>日志清理策略两个：保留时间 存储数据大小</p> <h5 id="高性能设计有了解过嘛"><a href="#高性能设计有了解过嘛" class="header-anchor">#</a> 高性能设计有了解过嘛</h5> <p>消息分区</p> <p>顺序读写</p> <p>页缓存</p> <p>零拷贝</p> <p>消息压缩</p> <p>分批发送</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2024/11/22 17:43:46</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#掌握技术" class="sidebar-link reco-side-掌握技术" data-v-b57cc07c>掌握技术</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#javase" class="sidebar-link reco-side-javase" data-v-b57cc07c>Javase</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#框架" class="sidebar-link reco-side-框架" data-v-b57cc07c>框架</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#mysql" class="sidebar-link reco-side-mysql" data-v-b57cc07c>MySQL</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#redis" class="sidebar-link reco-side-redis" data-v-b57cc07c>Redis</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#微服务" class="sidebar-link reco-side-微服务" data-v-b57cc07c>微服务</a></li><li class="level-3" data-v-b57cc07c><a href="/fang_blog/blogs/%E5%90%8E%E7%AB%AF/java/%E9%9D%A2%E8%AF%95/%E6%8A%80%E6%9C%AF%E6%A0%88%E9%97%AE%E7%AD%94.html#消息中间件" class="sidebar-link reco-side-消息中间件" data-v-b57cc07c>消息中间件</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:-1;" data-v-248d85d6></canvas></div><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/fang_blog/assets/js/app.8dbc3baf.js" defer></script><script src="/fang_blog/assets/js/3.d5c9c33c.js" defer></script><script src="/fang_blog/assets/js/1.3f023f4a.js" defer></script><script src="/fang_blog/assets/js/56.92051efa.js" defer></script>
  </body>
</html>
